---
id: 002
title: ChatKit Frontend Integration Planning
stage: plan
date: 2026-02-09
surface: agent
model: claude-sonnet-4-5-20250929
feature: 009-chatkit-frontend-integration
branch: 003-ai-todo-chatbot
user: user
command: /sp.plan
labels: [chatkit, frontend, ai, planning]
links:
  spec: /mnt/c/Users/DELL/Desktop/The_Evolution_of_todo/Phase_III/specs/009-chatkit-frontend-integration/spec.md
  ticket: null
  adr: null
  pr: null
files:
  - /mnt/c/Users/DELL/Desktop/The_Evolution_of_todo/Phase_III/specs/009-chatkit-frontend-integration/plan.md
tests:
  - null
---

## Prompt

Feature: Chatbot Frontend with Agent Integration

Create a minimal, clear implementation plan focused on
reliable agent communication and a polished chatbot UI.

Constraints:
- Follow the spec exactly
- Keep architecture simple
- No unnecessary abstractions
- Reuse existing auth/session logic
- Use Next.js + Tailwind + ChatKit

Plan must include:
1. Chat route/page structure
2. ChatKit component setup
3. Message state management
4. Agent API client
5. Chatbot layout and styling
6. Loading and error handling
7. README updates

Focus:
- Correct API integration
- Clean chatbot experience
- Simple, maintainable code

## Response snapshot

# Implementation Plan: ChatKit Frontend Integration

**Feature Branch**: `003-ai-todo-chatbot`
**Created**: 2026-02-09
**Status**: Ready for Implementation
**Spec**: [spec.md](./spec.md)

---

## Executive Summary

This plan implements a conversational chatbot interface using ChatKit to replace manual task UI. The chatbot connects to the AI agent backend through a simple REST API.

**Core Approach**:
- Floating widget overlay that adapts to existing page design
- React state management for message history (session-scoped)
- Direct API integration with agent endpoint
- Responsive layout optimized for both desktop and mobile
- Markdown rendering for agent responses with timestamps

**Key Constraints**:
- Reuse existing Better Auth session logic (user_id extraction)
- Use backend endpoint: `POST /api/{user_id}/chat`
- Keep architecture simpleâ€”no unnecessary abstractions
- Match existing page design system (colors, typography, spacing)
- Functional over decorativeâ€”minimalist styling for task control

---

## Technical Context

### Backend API Contract

**Endpoint**: `POST /api/{user_id}/chat`

**Path Parameter**:
- `user_id`: Extracted from Better Auth session

**Request Body**:
```json
{
  "message": "Create a task to buy groceries"
}
```

**Response Body**:
```json
{
  "response": "I've added 'buy groceries' to your task list."
}
```

**Error Response**:
```json
{
  "detail": "Error message string"
}
```

**Authentication**: Better Auth JWT token in Authorization header

### Current Frontend Stack

- **Framework**: Next.js 16+ (App Router)
- **Auth**: Better Auth client with session management
- **Styling**: Tailwind CSS + custom design system
- **Typography**: Poppins font family
- **Components**: shadcn/ui base components
- **Dashboard**: `/app/dashboard/page.tsx` (current task management UI)

### Technology Decisions

- **Chat UI Library**: **OpenAI ChatKit SDK** (mandatory per Constitution Principle X)
- **State Management**: ChatKit built-in + React hooks for widget state
- **API Client**: Fetch API with error handling wrapper
- **Markdown**: ChatKit built-in markdown rendering
- **Layout**: Floating widget wrapper around ChatKit component
- **Responsive**: CSS media queries + Tailwind breakpoints (â‰¤768px mobile, >768px desktop)

---

## Constitution Check

**Critical Requirement**: Constitution Principle X mandates: *"The frontend MUST use OpenAI ChatKit as the primary user interface for task management."*

This plan **strictly adheres** to this requirement by using ChatKit SDK as the core chat UI component.

### Compliance Matrix

| Principle | Status | Verification |
|-----------|--------|--------------|
| **I. Multi-Tier Isolation** | âœ… PASS | All frontend code in `/frontend/`. No cross-tier imports. |
| **III. Secure by Design** | âœ… PASS | Uses Better Auth session. User ID in path, JWT auth required. |
| **IV. Zero Manual Coding** | âœ… PASS | All code generated by Claude Code following SDD workflow. |
| **VI. API Contract Enforcement** | âœ… PASS | Uses documented REST endpoint. Simple JSON request/response. |
| **X. ChatKit-Driven Conversational Interface** | âœ… PASS | **OpenAI ChatKit SDK is the core chat UI component (mandatory)**. All task operations via natural language chat. |

### Potential Violations

**None**. This feature strictly follows constitution principles:
- Frontend-only changes (Multi-Tier Isolation)
- No database changes needed (Persistence First)
- Reuses existing auth (Secure by Design)
- Simple REST API contract (API Contract Enforcement)

---

## Phase 0: Research & Design Decisions

### R-001: ChatKit SDK Integration

**Requirement**: OpenAI ChatKit SDK is **mandatory** per Constitution Principle X

**Research Needed**:
- ChatKit installation and setup process
- ChatKit API for message rendering and sending
- How to integrate ChatKit with custom floating widget wrapper
- ChatKit theming/styling capabilities to match page design
- ChatKit built-in features (markdown, timestamps, auto-scroll)

**Implementation Approach**:
- Use ChatKit `<Chat>` component as core UI
- Wrap ChatKit in custom floating widget container for positioning
- Leverage ChatKit built-in markdown rendering (satisfies FR-015)
- Use ChatKit message state management
- Add custom styling wrapper to match page design
- Integrate ChatKit `onSend` callback with our API client

### R-002: Floating Widget Layout Strategy

**Question**: How to position a floating widget that doesn't interfere with existing dashboard?

**Design Decision**:
- Desktop (>768px): Fixed bottom-right corner, `w-96 h-[600px]`, with toggle button
- Mobile (â‰¤768px): Full-screen overlay when open, slide-in animation
- Z-index: 50 (above dashboard content, below modals if any)
- Toggle button: Fixed bottom-right, circular, with chat icon

**Implementation**:
```css
/* Desktop */
.chat-widget {
  @apply fixed bottom-4 right-4 w-96 h-[600px] shadow-2xl rounded-lg;
}

/* Mobile */
@media (max-width: 768px) {
  .chat-widget {
    @apply inset-0 w-full h-full rounded-none;
  }
}
```

### R-003: Message Persistence Strategy

**Question**: Should messages persist across page reloads?

**Decision**: Session-only (no persistence across reloads)
- **Rationale**:
  - FR-008: "maintain message state in the frontend"
  - SC-005: "for the duration of the user session"
  - Backend stores conversation history (not frontend concern)
  - Simplifies implementation
- **Implementation**: React state only, cleared on unmount/reload

### R-004: Design System Colors

**Question**: What colors to use for chat bubbles and widget?

**Approach**: Extract from existing dashboard components

**Decision** (to be confirmed during implementation):
- Widget background: Match dashboard card backgrounds
- User messages: Primary accent color (right-aligned)
- Assistant messages: Neutral gray (left-aligned)
- Typing indicator: Subtle animation with primary color
- Error messages: Red accent for errors
- Timestamps: Muted gray text

---

## Data Model

### Frontend State Model

```typescript
// Message type
interface Message {
  id: string;                    // Frontend-generated UUID
  sender: 'user' | 'assistant';  // Message author
  content: string;               // Message text (plain for user, markdown for assistant)
  timestamp: Date;               // Client timestamp
}

// Chat widget state
interface ChatState {
  isOpen: boolean;               // Widget open/closed
  messages: Message[];           // Conversation history (session-scoped)
  isLoading: boolean;            // True when waiting for agent response
  error: string | null;          // Error message (null when no error)
  inputValue: string;            // Current input field value
}
```

**No Backend Changes**: This feature only adds frontend UI.

---

## Component Architecture

### Directory Structure

```
frontend/
â”œâ”€â”€ app/
â”‚   â””â”€â”€ dashboard/
â”‚       â””â”€â”€ page.tsx              # MODIFY - Add ChatWidget
â”œâ”€â”€ components/
â”‚   â””â”€â”€ chat/
â”‚       â”œâ”€â”€ ChatWidget.tsx        # NEW - Floating widget wrapper (contains ChatKit)
â”‚       â”œâ”€â”€ ChatKitWrapper.tsx    # NEW - ChatKit SDK integration component
â”‚       â”œâ”€â”€ ChatToggleButton.tsx  # NEW - Floating button to open/close
â”‚       â””â”€â”€ ChatTheme.tsx         # NEW - ChatKit theme configuration (optional)
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ chat.ts               # NEW - API client for chat endpoint
â”‚   â””â”€â”€ hooks/
â”‚       â””â”€â”€ useChatMessages.ts    # NEW - Message state + API integration
â”œâ”€â”€ package.json                  # MODIFY - Add ChatKit SDK + dependencies
â””â”€â”€ tailwind.config.ts            # MODIFY - ChatKit theme overrides (optional)
```

### Component Responsibilities

**ChatWidget.tsx**:
- Floating widget container (positioning, z-index, responsive layout)
- Manages open/closed state
- Wraps ChatKitWrapper component
- Handles desktop (fixed bottom-right) vs mobile (full-screen) layout
- Provides styling wrapper to match page design

**ChatKitWrapper.tsx**:
- Integrates OpenAI ChatKit SDK `<Chat>` component
- Manages message state array
- Handles ChatKit `onSend` callback â†’ calls API client
- Displays typing indicator while waiting for response (ChatKit built-in)
- Configures ChatKit theme/styling to match page design
- Leverages ChatKit built-in features:
  - Markdown rendering (FR-015)
  - Auto-scroll (FR-017)
  - Timestamps (FR-014)
  - Message bubbles (FR-002, FR-003)

**ChatToggleButton.tsx**:
- Floating circular button (bottom-right on desktop)
- Opens/closes chat widget
- Icon changes based on open/closed state
- Mobile-friendly touch target (44x44px minimum)

**ChatTheme.tsx** (Optional):
- ChatKit theme configuration object
- Extracts colors from existing page design system
- Defines user/assistant bubble styles
- Configures typography to match Poppins font

**useChatMessages.ts** (Custom Hook):
- Manages messages array state
- Handles send message logic (calls API client)
- Adds user message optimistically to state
- Adds agent response to state when received
- Manages loading state
- Handles errors gracefully (FR-013)
- Extracts user_id from Better Auth session

**lib/api/chat.ts** (API Client):
- `sendMessage(userId: number, message: string): Promise<string>`
- Handles fetch to `POST /api/{userId}/chat`
- Includes Better Auth JWT in headers
- Parses response `{ "response": string }`
- Handles errors (401/403/500)

---

## Implementation Plan

### Phase 1: Dependencies & API Client

**Tasks**:
1. Install ChatKit SDK: `pnpm add @openai/chatkit uuid`
2. Create directory structure (`components/chat/`, `lib/api/`, `lib/hooks/`)
3. Implement `lib/api/chat.ts` API client
   - Extract user_id from Better Auth session
   - Send POST to `/api/{user_id}/chat`
   - Request body: `{ "message": string }`
   - Parse response: `{ "response": string }`
   - Handle 401/403/500 errors with user-friendly messages
   - Return agent response text
4. Test API client in isolation

**Dependencies**: None (can start immediately)

**Acceptance Criteria**:
- ChatKit SDK installed successfully
- API client successfully calls endpoint and returns response
- Error handling works for all error cases

### Phase 2: ChatKit Integration & Message State

**Tasks**:
1. Implement `useChatMessages.ts` hook
   - Message array state management
   - Send message handler (calls API client)
   - Optimistically add user message to state
   - Add agent response to state when received
   - Loading state management
   - Error state management
   - Extract user_id from Better Auth session
2. Create `ChatKitWrapper.tsx`
   - Import and configure ChatKit `<Chat>` component
   - Wire up `messages` prop to state from `useChatMessages`
   - Implement `onSend` callback â†’ call `useChatMessages.sendMessage()`
   - Display loading indicator while waiting for response
   - Handle errors from API (display in chat as system message)
3. Test ChatKit rendering with mock messages

**Dependencies**: Phase 1 complete

**Acceptance Criteria**:
- ChatKit component renders correctly
- Messages display with proper styling (user right, assistant left)
- Markdown rendering works (ChatKit built-in)
- Timestamps display (ChatKit built-in)
- Auto-scroll works (ChatKit built-in)
- Send message flow works end-to-end

### Phase 3: Floating Widget Wrapper & Toggle

**Tasks**:
1. Create `ChatWidget.tsx` (floating widget container)
   - Wraps ChatKitWrapper component
   - Manages open/closed state
   - Responsive layout:
     - Desktop (>768px): `fixed bottom-4 right-4 w-96 h-[600px]`
     - Mobile (â‰¤768px): `fixed inset-0 w-full h-full` (full-screen)
   - Z-index layering (above dashboard, below modals)
   - Smooth open/close animations
2. Create `ChatToggleButton.tsx`
   - Floating button (fixed bottom-right)
   - Opens/closes ChatWidget
   - Chat icon (changes when open/closed)
   - Mobile-friendly touch target (44x44px minimum)
3. Integrate into dashboard page
   - Add ChatWidget to `/app/dashboard/page.tsx`
   - Position independently of dashboard content

**Dependencies**: Phase 2 complete

**Acceptance Criteria**:
- Toggle button opens/closes widget smoothly
- Widget positioned correctly on desktop (floating) and mobile (full-screen)
- No layout conflicts with dashboard
- ChatKit component visible inside widget wrapper

### Phase 4: Theming, Polish & Error Handling

**Tasks**:
1. Create ChatKit theme configuration (optional `ChatTheme.tsx`)
   - Extract existing page colors from dashboard
   - Configure ChatKit theme to match:
     - User message bubbles (right-aligned, primary color)
     - Assistant message bubbles (left-aligned, neutral color)
     - Widget background
     - Font family (Poppins)
   - Apply theme to ChatKitWrapper
2. Enhance error handling
   - Display errors as system messages in chat (not alerts)
   - Session expired (401/403): "Session expired. Please log in again."
   - Network errors: "Unable to connect. Please check your internet."
   - Agent unavailable (500): "Agent is currently unavailable. Please try again later."
3. Add empty state handling
   - Initial message: "Hi! I'm your AI task assistant. How can I help you today?"
   - Input placeholder: "Type a message... (e.g., 'Add a task to buy milk')"
4. Input validation
   - Prevent empty message submission (FR-012)
   - Disable input while loading (FR-019)
5. Test all functional requirements against spec

**Dependencies**: Phase 3 complete

**Acceptance Criteria**:
- Widget styling matches page design
- ChatKit theme applied successfully
- All errors display as inline chat messages
- Empty state message displays on first open
- Input validation works
- All FRs (FR-001 through FR-022) satisfied

### Phase 5: Testing & Documentation

**Tasks**:
1. Manual testing of all user stories
2. Test responsive layouts (desktop + mobile)
3. Test edge cases (long messages, rapid sending, errors)
4. Update README with chat feature documentation
5. Create PR with implementation summary

**Dependencies**: Phase 4 complete

**Acceptance Criteria**:
- All user stories pass
- All success criteria met
- README updated
- PR ready for review

---

## Dependencies

### New NPM Packages

```json
{
  "dependencies": {
    "@openai/chatkit": "latest",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "@types/uuid": "^10.0.0"
  }
}
```

**Justification**:
- `@openai/chatkit`: **Mandatory** - OpenAI ChatKit SDK (Constitution Principle X)
  - Provides built-in markdown rendering (satisfies FR-015)
  - Includes auto-scroll, timestamps, message bubbles (FR-014, FR-017)
  - Accessible, mobile-friendly chat UI components
- `uuid`: Generate unique message IDs client-side

**Note**: ChatKit includes markdown rendering built-in, so `react-markdown` and `remark-gfm` are not needed.

---

## API Integration Details

### User ID Extraction

```typescript
// In useChat.ts or chat.ts
import { useSession } from '@/lib/auth/session'; // Adjust to actual Better Auth import

const { data: session } = useSession();
const userId = session?.user?.id;

if (!userId) {
  throw new Error("User not authenticated");
}
```

### Request Flow

```typescript
// lib/api/chat.ts
export async function sendMessage(
  userId: number,
  message: string
): Promise<string> {
  const response = await fetch(`/api/${userId}/chat`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // JWT token automatically included by Better Auth
    },
    body: JSON.stringify({ message }),
  });

  if (!response.ok) {
    if (response.status === 401 || response.status === 403) {
      throw new Error('Session expired. Please log in again.');
    }
    if (response.status === 500) {
      throw new Error('Agent is currently unavailable. Please try again later.');
    }
    throw new Error('Failed to send message. Please try again.');
  }

  const data = await response.json();
  return data.response;
}
```

---

## Non-Functional Requirements

### Performance Targets
- **Initial Render**: Widget renders in <100ms
- **Message Send**: <5 seconds from send to response display (SC-001)
- **Animations**: Open/close transitions <300ms

### Accessibility Requirements
- **Keyboard Navigation**: Tab through input/button, Enter to send, Escape to close
- **Screen Readers**: ARIA labels on all interactive elements
- **Touch Targets**: Minimum 44x44px on mobile (FR-021)
- **Focus Management**: Focus input when widget opens

### Responsive Design
- **Desktop (>768px)**: Floating widget, 384px wide, 600px tall
- **Mobile (â‰¤768px)**: Full-screen overlay when open
- **No Horizontal Scroll**: FR-022

---

## Testing Strategy

### Manual Test Cases

**TC-001: Send Message and Receive Response**
- Open chat widget
- Type "Add a task to buy groceries"
- Press send
- Verify: User message appears right-aligned
- Verify: Typing indicator appears
- Verify: Agent response appears left-aligned within 5 seconds
- Verify: Auto-scroll to bottom

**TC-002: Markdown Rendering**
- Send "Show me all my tasks"
- Verify: Agent response renders with markdown (bold, lists, etc.)
- Verify: Code blocks (if any) render correctly

**TC-003: Error Handling**
- Disconnect network, send message
- Verify: Error message appears: "Failed to send message. Please try again."
- Clear session, send message
- Verify: Error message: "Session expired. Please log in again."

**TC-004: Input Validation**
- Try sending empty message
- Verify: Send button disabled or message not sent
- Send message while loading
- Verify: Input disabled, button disabled

**TC-005: Responsive Layout**
- Open widget on desktop (>768px)
- Verify: Floating widget bottom-right, 384x600px
- Open widget on mobile (â‰¤768px)
- Verify: Full-screen overlay

**TC-006: Session Persistence**
- Send 3 messages
- Close and reopen widget
- Verify: Messages still visible (session-scoped)
- Reload page
- Verify: Messages cleared (expected behavior per spec)

---

## Risk Analysis

### Risk 1: Design System Mismatch
- **Probability**: Medium
- **Impact**: Low (visual only)
- **Mitigation**: Extract colors from dashboard during implementation
- **Contingency**: Use Tailwind defaults, refine later

### Risk 2: Session Expiry During Chat
- **Probability**: Medium
- **Impact**: Medium
- **Mitigation**: Catch 401/403 errors, show clear error message
- **Contingency**: Redirect to login page

### Risk 3: Long Message Rendering Performance
- **Probability**: Low
- **Impact**: Low
- **Mitigation**: Test with large markdown responses
- **Contingency**: Add max-height with scroll for long messages

### Risk 4: Mobile Layout Conflicts
- **Probability**: Low
- **Impact**: Medium
- **Mitigation**: Test on real mobile devices early
- **Contingency**: Adjust z-index and positioning

---

## Success Criteria Validation

| ID | Criteria | Validation Method |
|----|----------|-------------------|
| SC-001 | Response in <5s | Manual timing during testing |
| SC-002 | Loads on desktop/mobile | Visual testing both viewports |
| SC-003 | 100% task commands work | Test all CRUD operations via chat |
| SC-004 | 90% success rate | Test common commands without retries |
| SC-005 | Message history preserved | Test session persistence |

---

## Deployment Plan

1. **Install dependencies**: `pnpm install`
2. **Build**: `pnpm run build`
3. **Type check**: `pnpm run type-check`
4. **Lint**: `pnpm run lint`
5. **Manual testing**: All test cases pass
6. **Deploy to staging**
7. **Smoke test staging**
8. **Deploy to production**
9. **Monitor errors** for 24 hours

---

## Rollback Plan

**If critical issues arise**:
1. Hide chat toggle button (CSS: `display: none`)
2. Remove ChatWidget from dashboard page
3. Redeploy frontend
4. Investigate and fix in feature branch
5. Re-test and re-deploy

**Impact**: No data loss (backend unchanged), dashboard unaffected

---

## Documentation Updates

### README.md Section

```markdown
## Chat Interface

The application includes an AI-powered chatbot for natural language task management.

### Using the Chat
1. Log in to your account
2. Navigate to the dashboard
3. Click the chat icon in the bottom-right corner
4. Type commands like:
   - "Add a task to buy milk"
   - "Show my tasks"
   - "Mark task 3 as done"
   - "Delete the grocery task"
5. The AI agent will respond conversationally

### Chat Features
- Markdown-formatted responses
- Auto-scroll to latest message
- Session-based conversation history
- Mobile-responsive design
```

---

## Next Steps

1. âœ… Approve this plan
2. â­ï¸ Run `/sp.tasks` to generate actionable task list
3. â­ï¸ Run `/sp.implement` to execute tasks
4. â­ï¸ Manual testing
5. â­ï¸ Create PR and deploy

---

**Plan Version**: 1.0
**Created**: 2026-02-09
**Status**: Ready for Tasks
**Approved By**: Pending

## Outcome

- âœ… Impact: Created comprehensive implementation plan for ChatKit frontend integration with correct API contract
- ðŸ§ª Tests: Manual test cases defined for all user stories
- ðŸ“ Files: Plan document created with detailed architecture and implementation phases
- ðŸ” Next prompts: Ready for /sp.tasks to generate implementation tasks
- ðŸ§  Reflection: Plan addresses all constitutional requirements including mandatory ChatKit SDK usage

## Evaluation notes (flywheel)

- Failure modes observed: None
- Graders run and results (PASS/FAIL): PASS
- Prompt variant (if applicable): Standard planning workflow
- Next experiment (smallest change to try): Generate tasks with /sp.tasks
