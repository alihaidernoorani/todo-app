# Implementation Plan: MCP Task Tools for AI Chatbot

**Branch**: `003-ai-todo-chatbot` | **Date**: 2026-02-09 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `Phase_III/specs/007-mcp-task-tools/spec.md`

## Summary

Create a stateless MCP server exposing five task management tools (add_task, list_tasks, complete_task, delete_task, update_task) using the Official MCP SDK. The tools enable AI agents to perform CRUD operations on tasks through a standardized protocol, maintaining strict user isolation and interacting with the existing FastAPI backend via REST endpoints.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: Official MCP SDK (mcp), httpx (async HTTP client), pydantic (validation)
**Storage**: Database operations via FastAPI backend REST API (Neon PostgreSQL via SQLModel)
**Testing**: pytest with pytest-asyncio for async tool testing
**Target Platform**: MCP server process (stateless, restart-safe)
**Project Type**: Multi-tier (agent tier addition to existing web application)
**Performance Goals**: <2s response time per tool invocation for datasets up to 1000 tasks per user
**Constraints**: Stateless design (no in-memory state), 100% user isolation enforcement, all operations via REST API
**Scale/Scope**: 5 MCP tools, `/agent/` directory structure, integration with backend

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### ✅ Multi-Tier Isolation (Principle I)
- All MCP server code resides in `Phase_III/agent/` directory
- No direct imports from `/backend/` or `/frontend/`
- Communication with backend exclusively via REST API
- **Status**: PASS - Agent tier properly isolated

### ✅ Persistence First (Principle II)
- No in-memory task storage in MCP server
- All data operations delegate to backend API
- Backend persists all changes to Neon PostgreSQL
- Stateless MCP server design enables restart safety
- **Status**: PASS - All persistence via database through backend API

### ✅ Secure by Design (Principle III)
- All MCP tools require user_id parameter for operation scoping
- Backend API enforces JWT authentication (MCP tools pass user context)
- User isolation enforced at database query level (backend responsibility)
- No cross-user data access possible
- **Status**: PASS - User-scoped authorization enforced

### ✅ Zero Manual Coding (Principle IV)
- MCP server and tool definitions generated by Claude Code
- Tool schemas, server configuration, and REST client generated
- **Status**: PASS - All code AI-generated

### ✅ Test-First Discipline (Principle V)
- Tool invocation tests written before implementation (optional but recommended)
- Tests verify tool selection, parameter extraction, REST API integration
- **Status**: PASS - Testing strategy defined

### ✅ API Contract Enforcement (Principle VI)
- MCP tools expose typed schemas (parameters and responses)
- Tools invoke backend REST endpoints (contracts already defined)
- Tool responses match backend API response schemas
- **Status**: PASS - MCP tools honor existing REST contracts

### ✅ MCP Tool-Based System Design (Principle VIII)
- Five stateless MCP tools using Official MCP SDK
- Tools enforce user_id scoping
- Tool schemas declare parameters with types and descriptions
- **Status**: PASS - Core requirement of feature

### ✅ Stateless Backend Principle (Principle IX)
- MCP server maintains no in-memory conversation or task state
- Each tool invocation is independent
- **Status**: PASS - Stateless design mandated

## Project Structure

### Documentation (this feature)

```text
Phase_III/specs/007-mcp-task-tools/
├── spec.md              # Feature specification (already exists)
├── plan.md              # This file
├── research.md          # Phase 0 output (next step)
├── data-model.md        # Phase 1 output (tool schemas)
├── quickstart.md        # Phase 1 output (how to run MCP server)
├── contracts/           # Phase 1 output (tool schemas in JSON/OpenAPI format)
└── tasks.md             # Phase 2 output (generated by /sp.tasks)
```

### Source Code (Phase_III)

```text
Phase_III/
├── agent/                          # NEW: Agent tier (Principle I)
│   ├── mcp_server/                 # MCP server implementation
│   │   ├── __init__.py
│   │   ├── server.py               # MCP server entry point
│   │   ├── tools/                  # Tool implementations
│   │   │   ├── __init__.py
│   │   │   ├── add_task.py         # add_task tool
│   │   │   ├── list_tasks.py       # list_tasks tool
│   │   │   ├── complete_task.py    # complete_task tool
│   │   │   ├── update_task.py      # update_task tool
│   │   │   └── delete_task.py      # delete_task tool
│   │   ├── client/                 # REST API client for backend
│   │   │   ├── __init__.py
│   │   │   └── backend_client.py   # Async HTTP client for FastAPI backend
│   │   └── schemas/                # Pydantic models for tool inputs/outputs
│   │       ├── __init__.py
│   │       └── task_schemas.py     # Task input/output models
│   ├── tests/                      # Agent tier tests
│   │   ├── __init__.py
│   │   ├── test_tools.py           # Tool invocation tests
│   │   └── test_backend_client.py  # REST client tests
│   ├── pyproject.toml              # Agent dependencies (mcp, httpx, pytest)
│   ├── uv.lock                     # uv lockfile
│   └── README.md                   # Agent setup and usage
│
├── backend/                        # Existing FastAPI backend
│   ├── src/
│   │   ├── models/task.py          # Task SQLModel (already exists)
│   │   ├── api/v1/tasks.py         # Task REST endpoints (already exists)
│   │   └── services/task_service.py # Task business logic (already exists)
│   └── tests/
│
└── frontend/                       # Existing Next.js frontend
    └── ...
```

**Structure Decision**: Added `/agent/` tier to Phase_III for MCP server code, following Multi-Tier Isolation principle. Agent communicates with Phase_III backend via REST API. No code duplication between tiers—agent uses REST client to invoke existing endpoints.

## Complexity Tracking

> **No constitution violations. All gates pass cleanly.**

---

## Phase 0: Research & Technology Validation

### Objective
Resolve all technology choices and integration patterns before design phase.

### Research Tasks

#### 1. Official MCP SDK Usage Patterns
- **Question**: How to structure an MCP server using the Official MCP SDK in Python?
- **Research Goal**: Understand server initialization, tool registration, and execution model
- **Deliverable**: Code patterns for MCP server setup and tool definition

#### 2. MCP Tool Schema Definition
- **Question**: How to define tool parameters and response schemas in MCP?
- **Research Goal**: Learn MCP's type system, validation, and schema documentation
- **Deliverable**: Template for tool schema definition

#### 3. Async HTTP Client for REST API Integration
- **Question**: Best practice for async HTTP calls from MCP tools to FastAPI backend?
- **Research Goal**: Evaluate httpx vs aiohttp, connection pooling, error handling
- **Deliverable**: REST client pattern with timeout, retry, and error handling

#### 4. User Context Propagation
- **Question**: How to pass user_id from MCP tool invocation to backend API?
- **Research Goal**: Understand MCP tool parameter handling and backend authorization
- **Deliverable**: User context flow diagram and implementation approach

#### 5. Stateless MCP Server Design
- **Question**: How to ensure MCP server is truly stateless and restart-safe?
- **Research Goal**: Identify state leakage risks and mitigation strategies
- **Deliverable**: Stateless design checklist

#### 6. Error Handling and Tool Responses
- **Question**: How should MCP tools return errors to AI agents?
- **Research Goal**: MCP error response format, user-friendly error messages
- **Deliverable**: Error taxonomy and response format

### Research Consolidation

**Output**: `research.md` with:
- MCP SDK server setup code example
- Tool schema template with type annotations
- REST client implementation pattern
- User context flow diagram
- Stateless design guidelines
- Error handling standards

**Success Criteria**: All technology choices resolved, rationale documented, alternatives considered.

---

## Phase 1: Design & Contracts

### Prerequisites
- `research.md` completed with all technology choices resolved

### 1.1 Data Model Design

**Output**: `data-model.md`

#### Tool Input/Output Schemas

**Tool 1: add_task**
- **Input Schema**:
  - `user_id` (string, required): User identifier for scoping
  - `title` (string, required, max 255 chars): Task title
  - `description` (string, optional, max 2000 chars): Task description
- **Output Schema**:
  - `task_id` (UUID): Created task identifier
  - `title` (string): Task title
  - `status` (string): Task status ("pending")
  - `created_at` (ISO 8601 timestamp): Creation time

**Tool 2: list_tasks**
- **Input Schema**:
  - `user_id` (string, required): User identifier for scoping
  - `status` (string, optional, enum: ["all", "pending", "completed"], default: "all"): Filter by status
- **Output Schema**:
  - `tasks` (array of objects):
    - `task_id` (UUID)
    - `title` (string)
    - `description` (string | null)
    - `status` (string): "pending" or "completed"
    - `priority` (string): "High", "Medium", "Low"
    - `created_at` (ISO 8601 timestamp)

**Tool 3: complete_task**
- **Input Schema**:
  - `user_id` (string, required): User identifier for scoping
  - `task_id` (UUID, required): Task to mark complete
- **Output Schema**:
  - `task_id` (UUID)
  - `title` (string)
  - `status` (string): "completed"

**Tool 4: update_task**
- **Input Schema**:
  - `user_id` (string, required): User identifier for scoping
  - `task_id` (UUID, required): Task to update
  - `title` (string, optional): New title
  - `description` (string, optional): New description
- **Output Schema**:
  - `task_id` (UUID)
  - `title` (string): Updated title
  - `description` (string | null): Updated description
  - `status` (string)

**Tool 5: delete_task**
- **Input Schema**:
  - `user_id` (string, required): User identifier for scoping
  - `task_id` (UUID, required): Task to delete
- **Output Schema**:
  - `success` (boolean): Always true on success
  - `message` (string): "Task deleted successfully"

#### Backend API Mapping

Each tool maps to existing Phase_III backend REST endpoints:

- `add_task` → `POST /api/{user_id}/tasks`
- `list_tasks` → `GET /api/{user_id}/tasks`
- `complete_task` → `PATCH /api/{user_id}/tasks/{id}/complete`
- `update_task` → `PUT /api/{user_id}/tasks/{id}`
- `delete_task` → `DELETE /api/{user_id}/tasks/{id}`

### 1.2 API Contracts

**Output**: `contracts/` directory

**File: `contracts/mcp_tools_schema.json`**
- OpenAPI-style schema for all five MCP tools
- Parameter definitions with types, constraints, descriptions
- Response schemas with success and error formats
- Error codes: 400 (invalid parameters), 404 (task not found), 403 (unauthorized), 500 (server error)

**File: `contracts/backend_client_spec.md`**
- REST API client interface specification
- Method signatures for each backend endpoint
- Error handling strategy (exceptions vs error objects)
- Timeout and retry configuration
- Connection pooling settings

### 1.3 Quickstart Guide

**Output**: `quickstart.md`

**Contents**:
1. **Prerequisites**: Python 3.13+, uv installed, backend running
2. **Installation**:
   ```bash
   cd Phase_III/agent
   uv sync
   ```
3. **Configuration**: Environment variables for backend URL, timeouts
4. **Running MCP Server**:
   ```bash
   uv run python -m mcp_server.server
   ```
5. **Testing Tools**: Example MCP tool invocations via CLI or test script
6. **Troubleshooting**: Common issues (backend not running, auth errors, network timeouts)

### 1.4 Agent Context Update

**Action**: Run `.specify/scripts/bash/update-agent-context.sh claude`

**Updates**:
- Add MCP SDK, httpx to technology list in `.claude/agent-context.md`
- Add `/Phase_III/agent/` directory to codebase structure
- Document MCP tool architecture for future context

---

## Phase 2: Task Generation (Blocked by Plan Completion)

**Note**: This phase is NOT executed by `/sp.plan`. After this plan is complete and approved, run `/sp.tasks` to generate actionable, dependency-ordered tasks from this plan and spec.

**Expected Task Breakdown** (preview):
1. Setup agent project structure and dependencies
2. Implement REST API client with connection pooling
3. Implement add_task MCP tool
4. Implement list_tasks MCP tool with status filtering
5. Implement complete_task MCP tool
6. Implement update_task MCP tool
7. Implement delete_task MCP tool
8. Create MCP server entry point and tool registration
9. Write tool invocation tests (all five tools)
10. Write backend client integration tests
11. Create quickstart documentation
12. Validate stateless design (restart test)

---

## Non-Goals (Explicit Exclusions)

- **AI agent conversation logic**: Not part of MCP server (future work)
- **Chat endpoint**: MCP server exposes tools, not chat interface
- **Frontend UI changes**: Separate concern
- **User authentication**: Backend responsibility; MCP tools assume user_id is valid
- **User entity management**: Out of scope per spec
- **Task analytics**: Not in MVP tool set
- **Real-time notifications**: Not required for MCP tools
- **Task sharing**: Not in scope

---

## Risks & Mitigations

### Risk 1: Backend API Downtime or Latency
- **Impact**: MCP tools fail or timeout if backend unavailable
- **Mitigation**: Implement connection pooling, retry logic with exponential backoff, clear timeout errors
- **Fallback**: Return user-friendly error message to agent

### Risk 2: User_id Validation Mismatch
- **Impact**: Tools accept invalid user_id, backend rejects request
- **Mitigation**: Document user_id format requirements, backend returns 403 for unauthorized access
- **Detection**: Integration tests with invalid user_ids

### Risk 3: Schema Drift Between MCP Tools and Backend API
- **Impact**: Tool responses don't match backend API changes
- **Mitigation**: Contract tests verify schema alignment, version backend API properly
- **Prevention**: Generate tool schemas from backend OpenAPI spec (future enhancement)

### Risk 4: Stateful Behavior Leakage
- **Impact**: MCP server crashes or behaves inconsistently after restart
- **Mitigation**: Code review for global variables, restart test in test suite
- **Validation**: Restart MCP server mid-test and verify tools still work

### Risk 5: Concurrent Tool Invocations
- **Impact**: Database locking or race conditions on concurrent task updates
- **Mitigation**: Backend database handles concurrency (PostgreSQL MVCC), REST API is idempotent
- **Testing**: Load test with 10 concurrent tool calls

---

## Success Metrics (from Spec)

- **SC-001**: Tasks persist across MCP server restarts (validated by restart test)
- **SC-002**: 100% user isolation (validated by cross-user access test)
- **SC-003**: <2s response time for 1000 tasks per user (validated by performance test)
- **SC-004**: 10 concurrent invocations without data corruption (validated by load test)
- **SC-005**: 100% success rate for valid parameters (validated by contract tests)
- **SC-006**: 0% cross-user data access (validated by authorization tests)
- **SC-007**: Immediate tool availability post-restart (validated by restart test)

---

## Follow-Up Work (Out of Scope for This Plan)

1. **Agent Conversation Logic**: OpenAI Agents SDK integration with MCP tools
2. **ChatKit Integration**: Frontend chat interface for conversational task management
3. **Advanced Tool Features**: Bulk operations, task search, filtering by priority/date
4. **Tool Observability**: Logging tool invocations to database for audit trails
5. **Tool Performance Optimization**: Caching, request batching
6. **MCP Server Deployment**: Containerization, process management, monitoring
7. **Agent System Prompt**: Crafting conversation flow and tool selection logic

---

## Appendix: Technology Justification

### Why Official MCP SDK?
- **Rationale**: Standardized protocol for agent tools, built-in schema validation, discoverable tool definitions
- **Alternatives Considered**: Custom REST API (more work, not standard), Function calling JSON (no protocol)
- **Decision**: Use MCP SDK for best-in-class agent tool integration

### Why httpx for REST Client?
- **Rationale**: Async support, connection pooling, timeout handling, modern API
- **Alternatives Considered**: aiohttp (more complex), requests (sync only)
- **Decision**: httpx for simplicity and async performance

### Why Stateless Design?
- **Rationale**: Horizontal scaling, restart safety, simplified deployment
- **Alternatives Considered**: In-memory task cache (violates Persistence First principle)
- **Decision**: Stateless enforced by constitution and spec requirements

---

**Plan Status**: ✅ COMPLETE - Ready for Phase 0 research

**Next Steps**:
1. Execute Phase 0 research to resolve MCP SDK patterns and REST client implementation
2. Generate `research.md` with consolidated findings
3. Proceed to Phase 1 design artifacts (`data-model.md`, `contracts/`, `quickstart.md`)
4. After plan complete, run `/sp.tasks` to generate implementation tasks
