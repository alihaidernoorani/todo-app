# Implementation Plan: Conversation and Message Models

**Branch**: `003-ai-todo-chatbot` | **Date**: 2026-02-09 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/006-conversation-message-models/spec.md`

## Summary

Implement database models for storing conversation sessions and messages to support Phase III's stateless AI chatbot architecture. The Conversation model tracks chat sessions with user ownership and lifecycle timestamps. The Message model stores individual user/assistant messages with chronological ordering. Both models follow Phase II patterns (SQLModel ORM, user_id scoping, Alembic migrations) and enforce data integrity through foreign keys and constraints.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: FastAPI, SQLModel, Alembic, Neon PostgreSQL
**Storage**: Neon PostgreSQL (existing Phase II database)
**Testing**: pytest (following Phase II test patterns)
**Target Platform**: Linux server (Vercel deployment)
**Project Type**: Web application (backend component)
**Performance Goals**:
- <100ms for conversation/message CRUD operations
- Support thousands of messages per conversation
- Efficient user-scoped queries with proper indexing

**Constraints**:
- Must maintain backward compatibility with existing Task model
- Must use same database connection and migration patterns as Phase II
- Must enforce user_id scoping at database level (prevent cross-user access)
- Must support stateless backend (no in-memory conversation state)

**Scale/Scope**:
- Expected: 10-100 conversations per user
- Expected: 10-1000 messages per conversation
- Database-level constraints prevent data corruption

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Multi-Tier Isolation
- ✅ **PASS**: Models reside in `backend/src/models/` (backend tier)
- ✅ **PASS**: No frontend or agent code in this feature
- ✅ **PASS**: Communication via REST API (future features will add endpoints)

### II. Persistence First
- ✅ **PASS**: All conversation/message data persisted to PostgreSQL
- ✅ **PASS**: Using SQLModel ORM (Phase II standard)
- ✅ **PASS**: Alembic migrations for schema changes
- ✅ **PASS**: No in-memory state - supports stateless backend

### III. Secure by Design
- ✅ **PASS**: user_id field indexed for efficient scoped queries
- ✅ **PASS**: Models designed for user-scoped authorization
- ⚠️ **DEFERRED**: JWT validation (handled by API layer in future features)

### IV. Zero Manual Coding
- ✅ **PASS**: All code generated by Claude Code via `/sp.implement`
- ✅ **PASS**: Following Spec → Plan → Tasks → Implement workflow

### V. Test-First Discipline
- ⚠️ **OPTIONAL**: Tests not explicitly requested in spec
- ✅ **READY**: Acceptance scenarios defined for future test implementation

### VI. API Contract Enforcement
- ⚠️ **DEFERRED**: REST endpoints (future feature will add CRUD APIs)
- ✅ **READY**: Models designed to support future API contracts

### Phase III Principles (VII-XIII)
- ✅ **ALIGNED**: Models support stateless backend principle (IX)
- ✅ **ALIGNED**: Foundation for conversation state persistence
- ⚠️ **FUTURE**: Agent/MCP integration (not in scope for models-only feature)

**Gate Status**: ✅ **PASS** - All applicable principles satisfied. Deferred items are out of scope for this feature.

## Project Structure

### Documentation (this feature)

```text
specs/006-conversation-message-models/
├── spec.md                    # Feature specification (complete)
├── plan.md                    # This file (in progress)
├── research.md                # Phase 0 output (to be generated)
├── data-model.md              # Phase 1 output (to be generated)
├── quickstart.md              # Phase 1 output (to be generated)
├── contracts/                 # Phase 1 output (to be generated)
│   └── (no API endpoints in this feature - models only)
├── checklists/
│   └── requirements.md        # Quality checklist (complete)
└── tasks.md                   # Phase 2 output (/sp.tasks command)
```

### Source Code (repository root)

```text
backend/
├── src/
│   ├── models/
│   │   ├── __init__.py           # Model exports (update)
│   │   ├── task.py               # Existing Task model (reference)
│   │   ├── auth.py               # Existing Auth model (reference)
│   │   ├── conversation.py       # NEW: Conversation model
│   │   └── message.py            # NEW: Message model
│   └── core/
│       └── database.py           # Existing database connection (reference)
└── alembic/
    └── versions/
        └── YYYYMMDD_HHMM_add_conversation_message_models.py  # NEW migration
```

**Structure Decision**: Web application structure (Option 2 from template). Backend-only feature adding new models to existing Phase II architecture. No frontend changes required. Models will be consumed by future API endpoints.

## Complexity Tracking

**No violations**. This feature fully complies with all constitution principles.

---

# Phase 0: Research & Technical Decisions

## Research Areas

### 1. SQLModel Patterns from Phase II ✅

**Decision**: Follow existing Task model patterns exactly

**Rationale**:
- Consistency across codebase
- Proven patterns already working in production
- Reduces cognitive load for developers

**Patterns to replicate**:
- Use `SQLModel` base class with `table=True`
- Define `__tablename__` explicitly
- Use `Field()` for column definitions with constraints
- Use `datetime.now(UTC)` for timestamp defaults
- Index `user_id` for scoped queries
- Use type hints with `|` syntax for optional fields

**Reference**: `backend/src/models/task.py` (see lines 9-23)

### 2. Relationship Modeling Best Practices ✅

**Decision**: Use explicit `conversation_id` foreign key with `index=True`

**Rationale**:
- SQLModel/SQLAlchemy relationships require explicit foreign keys
- Indexing foreign keys improves join performance
- Explicit approach matches existing codebase style (simple, clear)

**Alternatives Considered**:
- SQLAlchemy `relationship()` with backpopulates: Rejected (adds complexity, ORM features not needed)
- Implicit foreign keys: Rejected (explicit is better than implicit)

**Implementation**:
```python
# In Message model:
conversation_id: int = Field(foreign_key="conversations.id", nullable=False, index=True)
```

### 3. Primary Key Strategy ✅

**Decision**: Use auto-incrementing integers for both Conversation and Message

**Rationale**:
- Existing Task model uses UUID, but conversations/messages benefit from sequential IDs
- Sequential IDs enable simple chronological ordering
- Smaller index size (int vs UUID) improves query performance
- PostgreSQL `SERIAL` type provides automatic incrementing

**Alternatives Considered**:
- UUID (like Task model): Rejected (sequential order lost, larger index size)
- Composite keys: Rejected (unnecessary complexity)

**Implementation**:
```python
id: int | None = Field(default=None, primary_key=True)  # PostgreSQL auto-increment
```

### 4. Message Role Enum ✅

**Decision**: Store role as string with application-layer validation

**Rationale**:
- SQLModel doesn't have native enum support like Pydantic
- PostgreSQL ENUM types require migrations and add complexity
- String with CHECK constraint or Pydantic validation is simpler
- Future-proof: easy to add new roles (e.g., "system", "tool")

**Alternatives Considered**:
- PostgreSQL ENUM: Rejected (migration complexity, hard to modify)
- Python Enum with custom mapping: Rejected (over-engineering for 2 values)

**Implementation**:
```python
role: str = Field(nullable=False, index=False)  # "user" or "assistant"
# Validation handled by Pydantic models in API layer
```

### 5. Timestamp Auto-Update Strategy ✅

**Decision**: Use database trigger or application-layer update for `updated_at`

**Rationale**:
- SQLModel/SQLAlchemy doesn't provide automatic `onupdate` for `updated_at`
- Options: Database trigger (PostgreSQL) or application logic
- **Chosen**: Application logic (simpler, no DB-specific SQL)

**Implementation**:
```python
# In Conversation model:
updated_at: datetime = Field(
    default_factory=lambda: datetime.now(UTC),
    nullable=False,
)
# API layer will update this field when adding messages
```

### 6. Cascade Delete Behavior ✅

**Decision**: Use `ondelete="CASCADE"` for message → conversation relationship

**Rationale**:
- Spec requirement: "when conversation deleted, messages should also be deleted"
- Database-level cascade ensures integrity even if application logic fails
- Standard pattern for parent-child relationships

**Implementation**:
```python
conversation_id: int = Field(
    foreign_key="conversations.id",
    nullable=False,
    index=True,
    sa_column_kwargs={"ondelete": "CASCADE"}
)
```

### 7. Text Content Storage ✅

**Decision**: Use PostgreSQL `TEXT` type (no length limit)

**Rationale**:
- Message content can vary (short replies to long explanations)
- TEXT type in PostgreSQL has no practical limit (up to 1GB)
- Application layer can validate if needed (e.g., 100KB limit)
- Simpler than arbitrary VARCHAR limits

**Implementation**:
```python
content: str = Field(nullable=False, sa_column_kwargs={"type_": Text()})
```

---

# Phase 1: Data Model & Contracts

## Data Model

### Entity: Conversation

**Purpose**: Represents a chat session between a user and the AI assistant

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | `int` | Primary Key, Auto-increment | Unique conversation identifier |
| `user_id` | `str` | NOT NULL, Indexed | Owner of the conversation (FK to auth system) |
| `created_at` | `datetime` | NOT NULL, Default: UTC now | When conversation was created |
| `updated_at` | `datetime` | NOT NULL, Default: UTC now | Last message timestamp |

**Indexes**:
- Primary: `id`
- Secondary: `user_id` (for efficient user-scoped queries)
- Composite: `(user_id, updated_at DESC)` for "recent conversations" queries

**Table Name**: `conversations`

---

### Entity: Message

**Purpose**: Represents a single message in a conversation

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | `int` | Primary Key, Auto-increment | Unique message identifier |
| `conversation_id` | `int` | Foreign Key (conversations.id), NOT NULL, Indexed, CASCADE DELETE | Parent conversation |
| `user_id` | `str` | NOT NULL, Indexed | Message owner (must match conversation owner) |
| `role` | `str` | NOT NULL | Sender role: "user" or "assistant" |
| `content` | `str` (TEXT) | NOT NULL | Message text content |
| `created_at` | `datetime` | NOT NULL, Default: UTC now | When message was created |

**Indexes**:
- Primary: `id`
- Secondary: `conversation_id` (for fetching conversation history)
- Secondary: `user_id` (for user-scoped queries)
- Composite: `(conversation_id, created_at ASC)` for chronological message ordering

**Table Name**: `messages`

**Foreign Keys**:
- `conversation_id` → `conversations.id` (CASCADE DELETE)

**Constraints**:
- `user_id` in Message SHOULD match `user_id` in Conversation (enforced at application layer)
- `role` SHOULD be "user" or "assistant" (enforced at application layer via Pydantic)

---

### Relationship Diagram

```
┌─────────────────────────┐
│ Conversation            │
├─────────────────────────┤
│ id (PK)                 │
│ user_id (IDX)           │
│ created_at              │
│ updated_at              │
└─────────────────────────┘
            │
            │ 1:N
            │
            ▼
┌─────────────────────────┐
│ Message                 │
├─────────────────────────┤
│ id (PK)                 │
│ conversation_id (FK)    │◄─── CASCADE DELETE
│ user_id (IDX)           │
│ role                    │
│ content                 │
│ created_at (IDX)        │
└─────────────────────────┘
```

---

### Example Data Flow

**Creating a new conversation with first message**:
1. POST /conversations → Create Conversation (id=1, user_id="abc", created_at=now, updated_at=now)
2. POST /conversations/1/messages → Create Message (id=1, conversation_id=1, user_id="abc", role="user", content="Hello")
3. Update Conversation.updated_at to Message.created_at

**Retrieving conversation history**:
1. GET /conversations/1/messages?user_id=abc
2. Query: SELECT * FROM messages WHERE conversation_id=1 AND user_id='abc' ORDER BY created_at ASC
3. Return messages in chronological order

**Deleting a conversation**:
1. DELETE /conversations/1?user_id=abc
2. PostgreSQL CASCADE DELETE automatically removes all messages with conversation_id=1
3. No orphaned messages remain

---

## API Contracts

**Note**: This feature implements models only. API endpoints will be added in a future feature. Contracts documented here for reference.

### Future Endpoint: Create Conversation

**Not implemented in this feature**

```
POST /api/conversations
Authorization: Bearer <JWT>

Response: 201 Created
{
  "id": 1,
  "user_id": "abc123",
  "created_at": "2026-02-09T10:00:00Z",
  "updated_at": "2026-02-09T10:00:00Z"
}
```

### Future Endpoint: Create Message

**Not implemented in this feature**

```
POST /api/conversations/{conversation_id}/messages
Authorization: Bearer <JWT>

Request:
{
  "role": "user",
  "content": "Hello, assistant!"
}

Response: 201 Created
{
  "id": 1,
  "conversation_id": 1,
  "user_id": "abc123",
  "role": "user",
  "content": "Hello, assistant!",
  "created_at": "2026-02-09T10:00:05Z"
}
```

### Future Endpoint: Get Conversation Messages

**Not implemented in this feature**

```
GET /api/conversations/{conversation_id}/messages
Authorization: Bearer <JWT>

Response: 200 OK
{
  "messages": [
    {
      "id": 1,
      "role": "user",
      "content": "Hello, assistant!",
      "created_at": "2026-02-09T10:00:05Z"
    },
    {
      "id": 2,
      "role": "assistant",
      "content": "Hello! How can I help you today?",
      "created_at": "2026-02-09T10:00:06Z"
    }
  ]
}
```

---

## Quickstart

### Prerequisites

- Python 3.13+
- PostgreSQL database (Neon or local)
- Existing Phase II backend setup
- Alembic configured

### Setup Steps

1. **Add new models to backend**:
   ```bash
   # Files will be created:
   # backend/src/models/conversation.py
   # backend/src/models/message.py
   ```

2. **Update model exports**:
   ```python
   # backend/src/models/__init__.py
   from .conversation import Conversation
   from .message import Message
   ```

3. **Generate Alembic migration**:
   ```bash
   cd backend
   alembic revision --autogenerate -m "Add conversation and message models"
   ```

4. **Review migration** (verify foreign keys, indexes, CASCADE):
   ```bash
   cat alembic/versions/<timestamp>_add_conversation_and_message_models.py
   ```

5. **Run migration**:
   ```bash
   alembic upgrade head
   ```

6. **Verify tables created**:
   ```bash
   psql -d <database_url> -c "\d conversations"
   psql -d <database_url> -c "\d messages"
   ```

### Testing Locally

```python
# Test in Python REPL
from backend.src.models import Conversation, Message
from backend.src.core.database import engine
from sqlmodel import Session, select

# Create session
session = Session(engine)

# Create conversation
conv = Conversation(user_id="test_user_123")
session.add(conv)
session.commit()
session.refresh(conv)
print(f"Created conversation: {conv.id}")

# Create message
msg = Message(
    conversation_id=conv.id,
    user_id="test_user_123",
    role="user",
    content="Test message"
)
session.add(msg)
session.commit()
print(f"Created message: {msg.id}")

# Query messages for conversation
stmt = select(Message).where(
    Message.conversation_id == conv.id,
    Message.user_id == "test_user_123"
).order_by(Message.created_at)
messages = session.exec(stmt).all()
print(f"Found {len(messages)} messages")
```

### Migration Rollback

```bash
# If needed, rollback migration
alembic downgrade -1
```

---

# Phase 2: Implementation Tasks

**Note**: Tasks will be generated by `/sp.tasks` command. This section outlines the expected task structure.

### Expected Task Breakdown

1. **Setup Tasks**:
   - Create `conversation.py` model file
   - Create `message.py` model file
   - Update `__init__.py` exports

2. **Model Implementation**:
   - Implement Conversation SQLModel with all fields and constraints
   - Implement Message SQLModel with all fields, foreign key, and constraints
   - Add proper type hints and Field configurations

3. **Migration Tasks**:
   - Generate Alembic migration script
   - Review migration for correctness (foreign keys, indexes, CASCADE)
   - Run migration on development database
   - Verify tables and constraints in database

4. **Validation Tasks** (Optional):
   - Write unit tests for model instantiation
   - Write integration tests for CRUD operations
   - Write test for cascade delete behavior
   - Write test for user_id scoping queries

---

## Risk Analysis

### Risk 1: Migration Conflicts with Existing Schema
**Likelihood**: Low
**Impact**: Medium
**Mitigation**: Review migration script before running; test on development database first; Alembic handles schema versioning

### Risk 2: Foreign Key Constraint Violations
**Likelihood**: Low
**Impact**: High
**Mitigation**: Alembic auto-generates correct foreign key syntax; manual review of migration; integration tests verify constraints work

### Risk 3: Performance Degradation with Large Message Counts
**Likelihood**: Medium
**Impact**: Medium
**Mitigation**: Indexes on conversation_id and created_at; future feature can add pagination; PostgreSQL handles millions of rows efficiently

### Risk 4: User ID Mismatch (Message.user_id ≠ Conversation.user_id)
**Likelihood**: Medium
**Impact**: High (data integrity violation)
**Mitigation**: Application-layer validation in API endpoints (future feature); consider database CHECK constraint in future if needed

---

## Success Metrics

- ✅ Alembic migration runs successfully on empty and populated databases
- ✅ Foreign key constraints prevent orphaned messages
- ✅ Cascade delete removes all messages when conversation deleted
- ✅ Indexes exist on user_id and conversation_id fields
- ✅ Query performance <100ms for typical conversation history retrieval
- ✅ Models follow Phase II patterns (consistent codebase)

---

## Next Steps

1. **Immediate**: Run `/sp.tasks` to generate actionable task list
2. **After tasks**: Run `/sp.implement` to execute implementation
3. **Future Features**:
   - Add REST API endpoints for CRUD operations
   - Add user_id validation middleware
   - Add pagination for large conversation histories
   - Add conversation metadata (title, tags, archived status)
   - Add message metadata (edited_at, token_count for LLM usage tracking)
