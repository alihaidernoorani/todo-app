# Research: Authentication and Security

**Feature**: 003-auth-security
**Date**: 2026-01-25
**Status**: Complete

## Overview

This document consolidates research findings for implementing stateless JWT authentication and authorization with Better Auth and FastAPI. Key focus areas include JWT library selection, Better Auth JWT payload structure, FastAPI dependency patterns, and HS256 security best practices.

---

## Task 1: Python JWT Library Evaluation

### Objective
Select the optimal JWT library for HS256 validation in Python 3.13+

### Options Evaluated

#### Option 1: python-jose[cryptography]
- **Maintainer**: Michael Davis (FastAPI community contributor)
- **Algorithm Support**: HS256, RS256, ES256, EdDSA
- **Performance**: Fast (C-based cryptography backend)
- **FastAPI Integration**: ‚úÖ Recommended by FastAPI official docs
- **Type Hints**: ‚úÖ Full Python 3.13 support
- **Security Track Record**: Well-audited, regular CVE patches
- **Documentation**: Excellent FastAPI-specific examples

**Pros**:
- Official FastAPI recommendation
- Cryptography backend for performance
- Comprehensive algorithm support
- Strong community adoption

**Cons**:
- Larger dependency footprint (cryptography)

#### Option 2: PyJWT
- **Maintainer**: Jos√© Padilla (industry standard)
- **Algorithm Support**: HS256, RS256, ES256, EdDSA
- **Performance**: Fast (C extensions available)
- **FastAPI Integration**: ‚ö†Ô∏è Works but less documented
- **Type Hints**: ‚úÖ Python 3.13 compatible
- **Security Track Record**: Excellent, industry-standard library
- **Documentation**: General-purpose (not FastAPI-specific)

**Pros**:
- Industry standard JWT library
- Excellent security track record
- Lightweight dependency

**Cons**:
- Less FastAPI-specific documentation
- Requires more boilerplate for FastAPI integration

#### Option 3: authlib
- **Maintainer**: Hsiaoming Yang (lepture)
- **Algorithm Support**: All JWT/JWE algorithms
- **Performance**: Good (pure Python + optional C)
- **FastAPI Integration**: ‚ö†Ô∏è Works but heavyweight
- **Type Hints**: ‚úÖ Python 3.13 compatible
- **Security Track Record**: Good, comprehensive library
- **Documentation**: OAuth/OpenID focused

**Pros**:
- Comprehensive auth library (JWT, OAuth, OpenID)
- Future-proof for OAuth integration

**Cons**:
- Heavyweight dependency (includes OAuth, OpenID)
- Overkill for simple JWT validation

### Decision

**Selected**: `python-jose[cryptography]` version 3.3.0+

**Rationale**:
1. **Official FastAPI recommendation** - Reduces integration risk
2. **Excellent documentation** - FastAPI security tutorial uses python-jose
3. **Performance** - Cryptography backend meets <50ms requirement
4. **Security** - Well-audited, active CVE response
5. **Type safety** - Full type hints for Python 3.13+

**Implementation Details**:
```python
# Installation
pip install python-jose[cryptography]

# Import
from jose import jwt, JWTError, ExpiredSignatureError

# Usage
payload = jwt.decode(
    token,
    secret_key,
    algorithms=["HS256"]
)
```

---

## Task 2: Better Auth JWT Claim Structure Research

### Objective
Understand the exact JWT payload structure generated by Better Auth

### Findings

**CRITICAL DISCOVERY**: Better Auth uses **EdDSA (Ed25519)** by default, **NOT HS256**.

#### Default JWT Header Structure

```json
{
  "alg": "EdDSA",    // Default algorithm (NOT HS256!)
  "kid": "c5c7995d-0037-4553-8aee-b5b620b89b23",  // Key ID
  "typ": "JWT"
}
```

#### Default JWT Payload Structure

```json
{
  "sub": "<user.id>",                    // Subject = User ID (customizable)
  "iss": "<BASE_URL>",                   // Issuer = BASE_URL env var
  "aud": "<BASE_URL>",                   // Audience = BASE_URL env var
  "exp": <timestamp_15_mins_from_now>,   // Expiration (default: 15 minutes)
  "iat": <current_timestamp>,            // Issued at
  // Entire user object spread here by default
  "id": "<user.id>",
  "email": "<user.email>",
  "name": "<user.name>"
  // ... additional user fields ...
}
```

#### Key Claims

1. **User ID**: Stored in `sub` claim (defaults to `user.id`)
2. **Expiration**: Default 15 minutes (`exp` claim)
3. **Standard Claims**: `iss`, `aud`, `exp`, `iat`, `sub`
4. **User Data**: Entire user object included by default (can be customized)

#### Better Auth JWT Configuration for HS256

**IMPORTANT**: To use HS256 as required by the spec, Better Auth must be configured with a custom signing strategy:

```typescript
// Better Auth configuration (frontend)
jwt({
  jwt: {
    // Custom payload definition
    definePayload: ({ user }) => {
      return {
        uid: user.id,      // Use 'uid' instead of default 'sub'
        email: user.email,
        role: user.role
      }
    },

    // CRITICAL: Configure HS256 signing (not default EdDSA)
    customSign: async ({ payload }) => {
      // Use jose library with HS256
      const token = await new jose.SignJWT(payload)
        .setProtectedHeader({ alg: 'HS256' })
        .setIssuedAt()
        .setExpirationTime('15m')
        .sign(new TextEncoder().encode(process.env.BETTER_AUTH_SECRET))
      return token
    },

    // Custom verification (if needed)
    customVerify: async ({ token }) => {
      const { payload } = await jose.jwtVerify(
        token,
        new TextEncoder().encode(process.env.BETTER_AUTH_SECRET)
      )
      return payload
    }
  }
})
```

#### Claim Mapping for Spec Requirements

| Spec Requirement | Better Auth Default | Required Configuration |
|------------------|---------------------|------------------------|
| User ID claim: `uid` | `sub` | Custom `definePayload` to use `uid` |
| Algorithm: HS256 | EdDSA (Ed25519) | Custom `customSign` with HS256 |
| Shared secret | Key pair (public/private) | Use BETTER_AUTH_SECRET in customSign |

### Decision

**For MVP**: Assume Better Auth is configured with HS256 and `uid` claim as specified.

**Documentation Required**: Create configuration guide for Better Auth frontend setup to ensure HS256 compatibility.

**Alternative Approach**: If Better Auth cannot be configured for HS256, the FastAPI backend can support **both EdDSA and HS256** validation:

```python
# Multi-algorithm support
algorithms = ["HS256", "EdDSA"]  # Support both
payload = jwt.decode(token, secret_key, algorithms=algorithms)
```

**Recommendation**: Clarify with frontend team whether Better Auth will be configured for HS256 or if backend should support EdDSA.

---

## Task 3: FastAPI Dependency Best Practices

### Objective
Design FastAPI dependencies that follow framework conventions

### Research Findings

#### Pattern 1: OAuth2PasswordBearer (FastAPI Built-in)

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(token: str = Depends(oauth2_scheme)):
    # Validates presence of Authorization header
    # Extracts token automatically
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    # ... validate token ...
    return user
```

**Pros**:
- Automatic OpenAPI documentation
- Built-in header extraction
- Standard OAuth2 compliance

**Cons**:
- Requires `/token` endpoint (not applicable for Better Auth)
- Less flexible for custom error messages

#### Pattern 2: Custom Security Dependency

```python
from fastapi import Depends, HTTPException, Header

async def get_current_user(authorization: str = Header(None)):
    if authorization is None:
        raise HTTPException(status_code=401, detail="Missing authentication token")

    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization header format")

    token = authorization.split(" ")[1]
    # ... validate token ...
    return user_id
```

**Pros**:
- Full control over error messages (FR-012 requirement)
- No OAuth2 endpoint dependency
- Simpler for JWT-only authentication

**Cons**:
- Manual OpenAPI documentation setup
- More boilerplate for header parsing

### Decision

**Selected**: Custom Security Dependency (Pattern 2)

**Rationale**:
1. **Error message control** - Spec requires specific error messages (FR-012)
2. **No OAuth2 endpoint** - Better Auth handles token issuance
3. **Simplicity** - JWT-only authentication doesn't need OAuth2 complexity
4. **Flexibility** - Easy to customize for user ID scoping

#### Error Handling Strategy

**Decision**: Raise `HTTPException` from dependencies (fail-fast)

```python
from fastapi import HTTPException, status

def verify_token(token: str) -> str:
    try:
        payload = jwt.decode(token, secret, algorithms=["HS256"])
        return payload["uid"]
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token expired",
            headers={"WWW-Authenticate": "Bearer"}
        )
    except jwt.JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token signature"
        )
```

**Rationale**:
- FastAPI convention for authentication failures
- Prevents endpoint handlers from null checking
- Automatic error response formatting
- Clear exception-to-status-code mapping

#### Path Parameter Extraction

**Decision**: Explicit dependency parameter injection

```python
async def verify_user_access(
    user_id: str,  # FastAPI injects from path {user_id}
    current_user_id: str = Depends(get_current_user)
) -> str:
    if current_user_id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied: cannot access another user's resources"
        )
    return current_user_id
```

**Rationale**:
- Explicit is better than implicit (PEP 20)
- Type-safe parameter validation
- Clear dependency contract
- Easy to test in isolation

---

## Task 4: HS256 Security Best Practices

### Objective
Ensure secure implementation of HS256 signature verification

### Research Findings

#### Secret Length Requirements

**RFC 7518 Recommendation**: Minimum 256 bits (32 characters) for HS256

**OWASP Recommendation**: ‚â•256 bits, prefer 512 bits for production

**Implementation**:
```python
# Pydantic validation
class Settings(BaseSettings):
    BETTER_AUTH_SECRET: str

    @validator('BETTER_AUTH_SECRET')
    def validate_secret_length(cls, v):
        if len(v) < 32:
            raise ValueError('BETTER_AUTH_SECRET must be at least 32 characters (256 bits)')
        return v
```

#### Timing Attack Mitigation

**Finding**: Python JWT libraries use constant-time comparison internally.

**python-jose**: Uses `hmac.compare_digest()` for signature verification (constant-time)

**No custom implementation needed** - Library handles timing attack prevention.

#### Validation Sequence (OWASP JWT Cheatsheet)

1. **Verify signature** before trusting any claims
2. **Check expiration** (`exp` claim) immediately after signature
3. **Validate issuer** (`iss`) if applicable
4. **Validate audience** (`aud`) if applicable
5. **Extract claims** only after all validation passes

**Implementation**:
```python
def decode_jwt(token: str) -> dict:
    try:
        # Step 1-4: python-jose handles signature + claim validation
        payload = jwt.decode(
            token,
            settings.BETTER_AUTH_SECRET,
            algorithms=["HS256"],
            options={
                "verify_signature": True,  # CRITICAL
                "verify_exp": True,        # Check expiration
                "verify_iat": True,        # Validate issued-at
                "require_exp": True,       # Require exp claim
                "require_iat": True        # Require iat claim
            }
        )

        # Step 5: Validate required claims
        if "uid" not in payload:
            raise ValueError("Missing uid claim")

        return payload

    except jwt.ExpiredSignatureError:
        raise  # Re-raise with specific error
    except jwt.JWTError as e:
        raise  # Re-raise for handling upstream
```

#### Secret Storage Best Practices

**Development**:
- Use `.env` file (add to `.gitignore`)
- Never commit secrets to version control

**Production**:
- Use environment variable injection (Docker, Kubernetes)
- Use secret management (AWS Secrets Manager, HashiCorp Vault)
- Rotate secrets periodically

**Implementation**:
```python
# .env.example (checked into repo)
BETTER_AUTH_SECRET=your-secret-here-min-32-chars

# .gitignore
.env
.env.local
```

#### Error Information Disclosure

**OWASP Guideline**: Don't leak internal state in error messages

**Good**:
- "Invalid token signature"
- "Token expired"
- "Missing authentication token"

**Bad** (information disclosure):
- "JWT signature verification failed using secret: abc123"
- "User ID mismatch: expected user-123 but got user-456"

**Implementation**:
```python
# Public error message (generic)
raise HTTPException(status_code=401, detail="Invalid token signature")

# Internal logging (detailed)
logger.warning(f"JWT validation failed: {str(e)}", extra={"token_header": header})
```

### Security Checklist

- ‚úÖ Secret minimum 32 characters (256 bits)
- ‚úÖ Verify signature before trusting claims
- ‚úÖ Enforce token expiration (`exp` claim)
- ‚úÖ Use constant-time comparison (library handles)
- ‚úÖ Never commit secrets to version control
- ‚úÖ Return generic error messages to clients
- ‚úÖ Log detailed errors server-side only
- ‚úÖ Validate all required claims (`uid`, `exp`, `iat`)

---

## Summary of Key Findings

### Critical Discoveries

1. **Better Auth Default Algorithm**: EdDSA (Ed25519), NOT HS256
   - **Action Required**: Configure Better Auth for HS256 OR support multi-algorithm validation
   - **Impact**: Frontend team must customize Better Auth JWT plugin

2. **User ID Claim**: Default is `sub`, spec requires `uid`
   - **Action Required**: Configure Better Auth `definePayload` to use `uid` key
   - **Impact**: Frontend configuration change needed

3. **Default Expiration**: 15 minutes (aligns with spec recommendation)
   - **No action needed**: Default is acceptable

### Library Selections

| Component | Selected Library | Version |
|-----------|------------------|---------|
| JWT Validation | python-jose[cryptography] | ‚â•3.3.0 |
| Environment Config | pydantic-settings | ‚â•2.0.0 |
| Testing | pytest + httpx | Latest stable |

### Architecture Patterns

| Pattern | Decision |
|---------|----------|
| Dependency Injection | Custom Header extraction (not OAuth2PasswordBearer) |
| Error Handling | Raise HTTPException (fail-fast) |
| Path Parameter Extraction | Explicit dependency parameter injection |
| Environment Variables | Pydantic BaseSettings with validation |

### Security Requirements

- Minimum secret length: 32 characters (256 bits)
- Algorithm: HS256 (requires Better Auth configuration)
- Validation sequence: Signature ‚Üí Expiration ‚Üí Claims
- Error messages: Generic public, detailed internal logs
- Secret storage: Environment variables, never committed

### Open Questions for Frontend Team

1. **Can Better Auth be configured to use HS256 instead of EdDSA?**
   - If yes: Provide configuration example
   - If no: Backend will support both EdDSA and HS256

2. **Can Better Auth payload use `uid` instead of `sub` for user ID?**
   - Requires `definePayload` customization
   - Backend will adapt based on confirmation

3. **What is the BETTER_AUTH_SECRET value?**
   - Must be shared between frontend and backend
   - Must be ‚â•32 characters

---

## Next Steps

1. ‚úÖ Complete data model design (Phase 1)
2. ‚úÖ Generate API contracts (Phase 1)
3. ‚úÖ Create quickstart guide (Phase 1)
4. üîÑ Coordinate with frontend team on Better Auth configuration
5. üîÑ Generate implementation tasks (`/sp.tasks`)
