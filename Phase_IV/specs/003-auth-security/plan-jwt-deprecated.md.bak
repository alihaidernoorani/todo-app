# Implementation Plan: Authentication and Security

**Branch**: `003-auth-security` | **Date**: 2026-01-25 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-auth-security/spec.md`

## Summary

Implement stateless JWT authentication and authorization for the FastAPI backend using Better Auth RS256 verification with JWKS. The system will validate JWT tokens from `Authorization: Bearer <token>` headers using RS256 algorithm with public keys retrieved from Better Auth's JWKS endpoint, extract user identity from the OIDC-standard `sub` claim, and enforce user-scoped access by comparing `sub` against `{user_id}` path parameters. Authentication failures return HTTP 401, authorization failures return HTTP 403. The architecture provides reusable FastAPI dependencies for consistent security enforcement across all protected endpoints.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**:
- FastAPI (web framework)
- PyJWT>=2.8.0 with cryptography>=41.0.0 (JWT library with RS256 and JWKS support)
- pydantic-settings (environment variable validation)
- httpx (for JWKS endpoint retrieval)
- pydantic (validation)
**Storage**: N/A (stateless verification, no database lookups for user status)
**Testing**: pytest, pytest-asyncio, httpx (FastAPI test client)
**Target Platform**: Linux/Docker containers, ASGI servers (uvicorn/gunicorn)
**Project Type**: Web (backend only for this feature)
**Performance Goals**: <50ms token validation overhead per request (excluding initial JWKS fetch which is cached)
**Constraints**:
- 100% stateless (no session storage, cookies, or server-side state)
- RS256 asymmetric algorithm with JWKS public key retrieval (Better Auth default)
- No database lookups during authentication/authorization
- Backend must be able to reach Better Auth JWKS endpoint
**Scale/Scope**: Supports unlimited concurrent authenticated users (stateless design)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle Compliance Analysis

**I. Multi-Tier Isolation**
- âœ… **PASS**: All authentication code will reside in `/backend/src/auth/` directory
- âœ… **PASS**: No frontend code involved in this feature (frontend handles Better Auth client integration separately)
- âœ… **PASS**: Clear separation maintained between backend auth logic and frontend token acquisition

**II. Persistence First**
- âœ… **PASS**: Authentication uses stateless JWT validation (no persistence required)
- âœ… **PASS**: User data persistence is handled by separate user management feature (not in scope)
- âš ï¸ **ACCEPTABLE EXCEPTION**: No database used for auth validation per design requirement (spec.md line 88: "rely solely on JWT validity")

**III. Secure by Design**
- âœ… **PASS**: Every protected endpoint will require JWT validation via FastAPI dependencies
- âœ… **PASS**: JWT verification uses RS256 asymmetric algorithm with JWKS public keys (no shared secrets)
- âœ… **PASS**: Public keys retrieved from Better Auth JWKS endpoint (supports key rotation)
- âœ… **PASS**: Token expiry enforced via `exp` claim validation
- âœ… **PASS**: Failed authentication returns 401, failed authorization returns 403 (FR-007, FR-008)
- âš ï¸ **NOTE**: Refresh token flow is out of scope per spec (handled by Better Auth frontend)

**IV. Zero Manual Coding**
- âœ… **PASS**: All code generated by Claude Code via `/sp.implement` workflow
- âœ… **PASS**: Every change traceable via PHR in `history/prompts/003-auth-security/`

**V. Test-First Discipline**
- âœ… **PASS**: Contract tests will be written for authentication/authorization scenarios
- âœ… **PASS**: Integration tests will cover user journey acceptance scenarios from spec
- âœ… **PASS**: Unit tests will validate JWT parsing, signature verification, and claim extraction

**VI. API Contract Enforcement**
- âœ… **PASS**: Authentication dependency outputs standardized error responses (FR-012)
- âœ… **PASS**: FastAPI auto-generates OpenAPI documentation for protected endpoints
- âœ… **PASS**: Error responses follow consistent JSON structure

**Technology Standards Compliance**:
- âœ… Python 3.13+
- âœ… FastAPI (latest stable)
- âœ… Better Auth JWT (shared secret verification)
- âœ… pytest for testing
- âœ… ruff for linting/formatting

**Overall Gate Status**: âœ… **PASS** - All principles satisfied. One acceptable exception (no DB persistence) is justified by spec requirement for stateless design.

## Project Structure

### Documentation (this feature)

```text
specs/003-auth-security/
â”œâ”€â”€ spec.md              # Feature requirements (completed)
â”œâ”€â”€ plan.md              # This file (/sp.plan command output)
â”œâ”€â”€ research.md          # Phase 0 output: JWT library comparison, best practices
â”œâ”€â”€ data-model.md        # Phase 1 output: JWT payload structure, error schemas
â”œâ”€â”€ quickstart.md        # Phase 1 output: Developer guide for using auth dependencies
â”œâ”€â”€ contracts/           # Phase 1 output: API error response contracts
â”‚   â””â”€â”€ auth-errors.json # OpenAPI schema for authentication error responses
â””â”€â”€ tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ dependencies.py    # FastAPI authentication/authorization dependencies
â”‚   â”‚   â”œâ”€â”€ jwt_handler.py     # JWT validation, parsing, claim extraction, JWKS retrieval
â”‚   â”‚   â””â”€â”€ exceptions.py      # Custom authentication exception classes
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ auth.py            # Pydantic models for JWT payload, error responses
â”‚   â””â”€â”€ config.py              # Environment variable configuration (BETTER_AUTH_URL, JWKS endpoint)
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ contract/
â”‚   â”‚   â””â”€â”€ test_auth_contract.py  # Contract tests for authentication behavior
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â””â”€â”€ test_auth_integration.py  # Integration tests with FastAPI endpoints
â”‚   â””â”€â”€ unit/
â”‚       â”œâ”€â”€ test_jwt_handler.py      # Unit tests for JWT validation logic
â”‚       â””â”€â”€ test_auth_dependencies.py # Unit tests for FastAPI dependencies
â””â”€â”€ .env.example         # Example environment variables (BETTER_AUTH_URL, JWKS endpoint)
```

**Structure Decision**: Web application (Option 2) - Backend-only feature. Code resides exclusively in `/backend/` directory per Multi-Tier Isolation principle. The `auth/` module provides reusable security components that will be imported by other backend features (task management, user management) when protecting their endpoints.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations requiring justification. The one acceptable exception (no database persistence for auth) is explicitly required by the specification's stateless design constraint.

---

# Phase 0: Research

## Research Tasks

### Task 1: Python JWT Library Evaluation for RS256 + JWKS

**Objective**: Select the optimal JWT library for RS256 validation with JWKS support in Python 3.13+

**Research Questions**:
- Which Python JWT libraries support RS256 algorithm with JWKS retrieval?
- What are the performance characteristics of each library for asymmetric verification?
- Which library has the most active maintenance and security track record?
- Which library integrates best with FastAPI and Pydantic?
- How do libraries handle JWKS caching to minimize network overhead?

**Options to Evaluate**:
- `PyJWT` with `cryptography` - Industry standard, explicit RS256 support, JWKS via PyJWKClient
- `python-jose[cryptography]` - Popular with FastAPI community, cryptography backend
- `authlib` - Comprehensive auth library by lepture with built-in JWKS support

**Decision Criteria**:
- RS256 and JWKS support out of the box
- Security audit history and CVE response time
- Performance (<50ms validation requirement with JWKS caching)
- Type hints and Python 3.13 compatibility
- FastAPI integration examples and community support

### Task 2: Better Auth JWT Claim Structure Research

**Objective**: Verify the exact JWT payload structure generated by Better Auth with RS256

**Research Questions**:
- What claims does Better Auth include in JWT tokens by default with RS256?
- Confirm user ID claim uses OIDC-standard `sub` (not custom `uid`)
- What additional claims are included (`exp`, `iat`, `iss`, `aud`)?
- What is the JWT header structure (algorithm: RS256, kid for key identification)?
- Where is the JWKS endpoint exposed by Better Auth (typically `/.well-known/jwks.json`)?

**Information Sources**:
- Better Auth documentation via MCP search
- Better Auth GitHub repository examples
- Better Auth JWT plugin configuration reference
- OIDC specification for standard claims

**Required Output**: Documented JWT payload schema with `sub` claim for validation

### Task 3: FastAPI Dependency Best Practices

**Objective**: Design FastAPI dependencies that follow framework conventions

**Research Questions**:
- What is the recommended pattern for authentication dependencies in FastAPI?
- How to handle dependency failures (raise exceptions vs return None)?
- How to extract path parameters within dependencies for authorization?
- How to provide consistent error responses from dependencies?

**Information Sources**:
- FastAPI official documentation (Security section)
- FastAPI dependency injection patterns
- OAuth2PasswordBearer vs custom dependency patterns

**Required Output**: Dependency design pattern with error handling strategy

### Task 4: RS256 + JWKS Security Best Practices

**Objective**: Ensure secure implementation of RS256 signature verification with JWKS

**Research Questions**:
- What validation steps must occur before trusting JWT claims with RS256?
- How to securely retrieve and cache JWKS keys to prevent DoS?
- What JWKS key rotation best practices should be followed?
- How to handle JWKS endpoint failures gracefully?
- What timing attack considerations exist for RS256 (less critical than HS256)?

**Information Sources**:
- OWASP JWT security cheatsheet
- RFC 7519 (JSON Web Token) specification
- RFC 7517 (JSON Web Key) specification
- Python JWT library security documentation for RS256/JWKS

**Required Output**: Security checklist for RS256 JWT validation implementation with JWKS

---

# Phase 1: Design & Contracts

## Data Model

### JWT Token Payload Structure

**Source**: Better Auth JWT plugin output with RS256 (OIDC-compliant)

```python
# Expected JWT payload structure from Better Auth
{
    "sub": "string",           # User unique identifier (OIDC-standard subject claim)
    "exp": int,                # Expiration timestamp (Unix epoch seconds)
    "iat": int,                # Issued at timestamp (Unix epoch seconds)
    "iss": "string",           # Issuer (Better Auth URL)
    # Additional claims TBD based on Better Auth configuration
}
```

**JWT Header Structure**:
```python
{
    "alg": "RS256",            # Algorithm (asymmetric)
    "typ": "JWT",              # Token type
    "kid": "string"            # Key ID for JWKS lookup
}
```

**Validation Requirements**:
- `sub` must be present and non-empty string (OIDC-standard user ID claim)
- `exp` must be present and greater than current timestamp
- `iat` must be present and less than or equal to current timestamp
- Signature must verify using public key from JWKS endpoint matching `kid` header
- `kid` in header must match a key in the JWKS endpoint response

### Authentication Error Response Schema

```json
{
  "detail": "string",          // Human-readable error message
  "error_code": "string",      // Machine-readable error identifier
  "status_code": int           // HTTP status code (401 or 403)
}
```

**Error Codes**:
- `MISSING_TOKEN`: Authorization header not provided
- `INVALID_HEADER_FORMAT`: Authorization header not in "Bearer <token>" format
- `INVALID_TOKEN_SIGNATURE`: JWT signature verification failed (RS256 public key mismatch)
- `TOKEN_EXPIRED`: JWT exp claim is in the past
- `MALFORMED_TOKEN`: JWT parsing failed (invalid structure)
- `MISSING_SUB_CLAIM`: JWT payload missing required sub claim (OIDC user ID)
- `JWKS_FETCH_FAILED`: Unable to retrieve public keys from Better Auth JWKS endpoint
- `INVALID_KID`: JWT header kid does not match any key in JWKS
- `FORBIDDEN_USER_ACCESS`: Authenticated user attempting to access different user's resources

### Configuration Schema

```python
# Environment variables required for authentication
BETTER_AUTH_URL: str              # Base URL of Better Auth instance (REQUIRED)
BETTER_AUTH_JWKS_URL: str         # Full JWKS endpoint URL (typically ${BETTER_AUTH_URL}/.well-known/jwks.json)
```

**Startup Validation**:
- Application must fail to start if BETTER_AUTH_URL is missing or empty
- Application must validate JWKS endpoint is reachable during startup
- JWKS endpoint must return valid JSON Web Key Set structure

## API Contracts

### Authentication Dependency Contract

**Dependency**: `get_current_user`

**Input**:
- HTTP Header: `Authorization: Bearer <jwt_token>`

**Output**:
- **Success**: Returns authenticated user ID (string) extracted from JWT `sub` claim (OIDC standard)
- **Failure**: Raises HTTPException with appropriate 401 status code and error detail

**Error Scenarios**:
| Scenario | Status Code | Error Code | Error Message |
|----------|-------------|------------|---------------|
| Missing Authorization header | 401 | MISSING_TOKEN | "Missing authentication token" |
| Invalid header format (not "Bearer <token>") | 401 | INVALID_HEADER_FORMAT | "Invalid authorization header format" |
| Invalid signature (RS256 verification failed) | 401 | INVALID_TOKEN_SIGNATURE | "Invalid token signature" |
| Expired token | 401 | TOKEN_EXPIRED | "Token expired" |
| Malformed token | 401 | MALFORMED_TOKEN | "Malformed token" |
| Missing sub claim | 401 | MISSING_SUB_CLAIM | "Invalid token: missing or malformed user ID claim" |
| JWKS fetch failed | 401 | JWKS_FETCH_FAILED | "Unable to verify token: authentication service unavailable" |
| Invalid kid in header | 401 | INVALID_KID | "Invalid token: unknown signing key" |

### Authorization Dependency Contract

**Dependency**: `verify_user_access`

**Input**:
- HTTP Header: `Authorization: Bearer <jwt_token>`
- Path Parameter: `{user_id}` (string)

**Output**:
- **Success**: Returns authenticated user ID (string) if it matches `{user_id}` path parameter
- **Authentication Failure**: Raises HTTPException with 401 status (same as `get_current_user`)
- **Authorization Failure**: Raises HTTPException with 403 status if user ID mismatch

**Error Scenarios**:
| Scenario | Status Code | Error Code | Error Message |
|----------|-------------|------------|---------------|
| All authentication errors | 401 | (see above) | (see above) |
| User ID mismatch | 403 | FORBIDDEN_USER_ACCESS | "Access denied: cannot access another user's resources" |

**Usage Pattern**:
```python
# Example protected endpoint
@router.get("/users/{user_id}/tasks")
async def get_user_tasks(
    user_id: str,
    current_user_id: str = Depends(verify_user_access)
):
    # current_user_id is guaranteed to equal user_id
    # Safe to proceed with business logic
    pass
```

## Key Architectural Decisions

### Decision 1: JWT Library Selection

**Decision**: Use `PyJWT>=2.8.0` with `cryptography>=41.0.0`

**Rationale**:
- Industry-standard library with excellent RS256 and JWKS support
- Built-in `PyJWKClient` for JWKS endpoint retrieval and caching
- Active maintenance and rapid security updates
- Explicit RS256 algorithm support with cryptography backend
- Type hint support for Python 3.13+
- Better performance for asymmetric cryptography compared to python-jose

**Alternatives Considered**:
- `python-jose[cryptography]`: Recommended by FastAPI docs but less robust JWKS support
- `authlib`: More comprehensive but heavier dependency (includes OAuth, OpenID)

**Implementation Impact**:
- Dependencies: `PyJWT>=2.8.0`, `cryptography>=41.0.0`
- Import path: `import jwt` (from PyJWT), `from jwt import PyJWKClient`
- JWKS caching handled automatically by PyJWKClient

### Decision 2: Dependency Error Handling Pattern

**Decision**: Raise `HTTPException` from dependencies (not `return None`)

**Rationale**:
- FastAPI convention for authentication dependencies
- Prevents endpoint handlers from having to check `if user is None`
- Consistent error responses across all protected endpoints
- Automatic OpenAPI documentation of authentication requirements

**Alternatives Considered**:
- Return `Optional[str]`: Requires every endpoint to handle None case (error-prone)
- Custom exception types: Adds complexity without benefit (HTTPException sufficient)

**Implementation Impact**:
```python
from fastapi import HTTPException, status

def verify_token(token: str) -> str:
    if not valid:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token expired",
            headers={"WWW-Authenticate": "Bearer"}
        )
    return user_id
```

### Decision 3: User ID Path Parameter Extraction

**Decision**: Accept `user_id: str` as explicit parameter to `verify_user_access` dependency

**Rationale**:
- Explicit is better than implicit (Zen of Python)
- FastAPI automatically injects path parameters into dependencies
- Clear contract: dependency requires user_id to perform authorization
- Type-safe: user_id parameter validated by Pydantic

**Alternatives Considered**:
- Parse path from Request object: Fragile (assumes URL structure)
- Use starlette.requests.Request.path_params: Less explicit, harder to test

**Implementation Impact**:
```python
async def verify_user_access(
    user_id: str,  # Automatically injected from path parameter {user_id}
    current_user_id: str = Depends(get_current_user)
) -> str:
    if current_user_id != user_id:
        raise HTTPException(status_code=403, ...)
    return current_user_id
```

### Decision 4: Environment Variable Loading

**Decision**: Use `pydantic-settings` for environment variable validation

**Rationale**:
- Type-safe configuration with validation
- Automatic parsing of environment variables
- Fail-fast on missing required configuration (SC-007 requirement)
- Integrates with FastAPI/Pydantic ecosystem

**Alternatives Considered**:
- `python-dotenv` + manual validation: More boilerplate, less type-safe
- `os.getenv()`: No validation, runtime errors instead of startup errors

**Implementation Impact**:
```python
from pydantic_settings import BaseSettings
from pydantic import HttpUrl

class Settings(BaseSettings):
    BETTER_AUTH_URL: HttpUrl  # Required field - raises error if missing or invalid URL

    @property
    def BETTER_AUTH_JWKS_URL(self) -> str:
        """Construct JWKS endpoint URL from base URL"""
        return f"{self.BETTER_AUTH_URL}/.well-known/jwks.json"

    class Config:
        env_file = ".env"

settings = Settings()  # Fails on import if BETTER_AUTH_URL invalid
```

### Decision 5: JWT Algorithm Strategy

**Decision**: Use RS256 with JWKS (Better Auth default)

**Rationale**:
- Asymmetric cryptography: private key stays with Better Auth, public key for verification
- No shared secrets between services (improved security posture)
- Supports key rotation without backend redeployment
- Industry standard for distributed authentication systems
- Better Auth default configuration (zero custom setup needed)
- OIDC-compliant (interoperable with other identity providers)

**Alternatives Considered**:
- HS256 with shared secret: Simpler but requires secret sharing, no key rotation support

**Implementation Impact**:
- Backend retrieves public keys from Better Auth JWKS endpoint
- PyJWKClient handles JWKS caching and automatic refresh
- No shared secret management required
- Supports multiple signing keys (key rotation scenarios)

## Testing Strategy

### Contract Tests

**File**: `tests/contract/test_auth_contract.py`

**Scenarios**:
1. Valid token with correct user ID â†’ 200 OK
2. Valid token with mismatched user ID â†’ 403 Forbidden
3. Expired token â†’ 401 Unauthorized
4. Invalid signature â†’ 401 Unauthorized
5. Missing Authorization header â†’ 401 Unauthorized
6. Malformed Authorization header â†’ 401 Unauthorized

**Test Data**:
- Generate valid JWT tokens using test secret
- Generate expired tokens (exp in past)
- Generate invalid signatures (wrong secret)
- Generate malformed tokens (invalid JSON, missing claims)

### Integration Tests

**File**: `tests/integration/test_auth_integration.py`

**Scenarios**:
1. Protected endpoint rejects unauthenticated requests
2. Protected endpoint accepts valid token with correct user ID
3. User-scoped endpoint rejects valid token with different user ID
4. Multiple concurrent requests with same token (stateless validation)
5. Error response format matches contract specification

**Setup**:
- Create test FastAPI app with protected endpoints
- Use `TestClient` from `fastapi.testclient`
- Mock BETTER_AUTH_SECRET with test value

### Unit Tests

**File**: `tests/unit/test_jwt_handler.py`

**Scenarios**:
1. `decode_jwt()` validates signature correctly
2. `decode_jwt()` rejects expired tokens
3. `decode_jwt()` extracts uid claim correctly
4. `decode_jwt()` raises appropriate exceptions for invalid tokens
5. `extract_bearer_token()` parses Authorization header correctly
6. `extract_bearer_token()` rejects malformed headers

**File**: `tests/unit/test_auth_dependencies.py`

**Scenarios**:
1. `get_current_user()` dependency calls jwt_handler correctly
2. `get_current_user()` raises HTTPException for invalid tokens
3. `verify_user_access()` compares user IDs correctly
4. `verify_user_access()` raises 403 for mismatched user IDs

## Implementation Phases

### Phase 0 Deliverables âœ…

- [x] `research.md` - JWT library evaluation, Better Auth claim structure, best practices
- [x] Architecture decisions documented above

### Phase 1 Deliverables âœ…

- [x] `data-model.md` - JWT payload schema, error response schema, configuration schema
- [x] `contracts/auth-errors.json` - OpenAPI error response contracts
- [x] `quickstart.md` - Developer guide for using authentication dependencies
- [x] Agent context updated (technology stack additions)

### Phase 2 Deliverables (via `/sp.tasks`)

- [ ] `tasks.md` - Actionable, dependency-ordered implementation tasks
- [ ] Task execution via `/sp.implement`

## Security Considerations

1. **Secret Management**:
   - BETTER_AUTH_SECRET must never be committed to version control
   - Use `.env` file for local development (add to `.gitignore`)
   - Use environment variable injection for production deployment

2. **Timing Attack Mitigation**:
   - JWT libraries use constant-time comparison for signatures (handled by python-jose)
   - No custom string comparison needed

3. **Token Expiration**:
   - Rely on Better Auth to set appropriate expiration times (15-30 minutes recommended)
   - Backend enforces expiration via `exp` claim validation
   - No grace period for expired tokens (strict validation)

4. **Error Information Disclosure**:
   - Return generic error messages to clients ("Invalid token signature")
   - Log detailed error information server-side for debugging
   - Never expose secret material or internal state in error responses

## Next Steps

1. âœ… Phase 1 complete - Architecture designed, contracts defined
2. ðŸ”„ Run `/sp.tasks` to generate actionable implementation tasks
3. ðŸ”„ Run `/sp.implement` to execute tasks with TDD workflow
4. ðŸ”„ Validate against acceptance criteria from spec.md
