# Implementation Plan: Authentication and Security

**Branch**: `003-auth-security` | **Date**: 2026-01-25 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-auth-security/spec.md`

## Summary

Implement stateless JWT authentication and authorization for the FastAPI backend using Better Auth shared secret verification. The system will validate JWT tokens from `Authorization: Bearer <token>` headers using HS256 algorithm, extract user identity from the `uid` claim, and enforce user-scoped access by comparing `uid` against `{user_id}` path parameters. Authentication failures return HTTP 401, authorization failures return HTTP 403. The architecture provides reusable FastAPI dependencies for consistent security enforcement across all protected endpoints.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: FastAPI, python-jose (JWT library), python-dotenv (environment variables), pydantic (validation)
**Storage**: N/A (stateless verification, no database lookups for user status)
**Testing**: pytest, pytest-asyncio, httpx (FastAPI test client)
**Target Platform**: Linux/Docker containers, ASGI servers (uvicorn/gunicorn)
**Project Type**: Web (backend only for this feature)
**Performance Goals**: <50ms token validation overhead per request
**Constraints**:
- 100% stateless (no session storage, cookies, or server-side state)
- HS256 symmetric algorithm only (shared secret with Better Auth)
- No database lookups during authentication/authorization
**Scale/Scope**: Supports unlimited concurrent authenticated users (stateless design)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle Compliance Analysis

**I. Multi-Tier Isolation**
- âœ… **PASS**: All authentication code will reside in `/backend/src/auth/` directory
- âœ… **PASS**: No frontend code involved in this feature (frontend handles Better Auth client integration separately)
- âœ… **PASS**: Clear separation maintained between backend auth logic and frontend token acquisition

**II. Persistence First**
- âœ… **PASS**: Authentication uses stateless JWT validation (no persistence required)
- âœ… **PASS**: User data persistence is handled by separate user management feature (not in scope)
- âš ï¸ **ACCEPTABLE EXCEPTION**: No database used for auth validation per design requirement (spec.md line 88: "rely solely on JWT validity")

**III. Secure by Design**
- âœ… **PASS**: Every protected endpoint will require JWT validation via FastAPI dependencies
- âœ… **PASS**: JWT verification uses shared secret (BETTER_AUTH_SECRET) with HS256 algorithm
- âœ… **PASS**: Token expiry enforced via `exp` claim validation
- âœ… **PASS**: Failed authentication returns 401, failed authorization returns 403 (FR-006, FR-007)
- âš ï¸ **NOTE**: Refresh token flow is out of scope per spec (handled by Better Auth frontend)

**IV. Zero Manual Coding**
- âœ… **PASS**: All code generated by Claude Code via `/sp.implement` workflow
- âœ… **PASS**: Every change traceable via PHR in `history/prompts/003-auth-security/`

**V. Test-First Discipline**
- âœ… **PASS**: Contract tests will be written for authentication/authorization scenarios
- âœ… **PASS**: Integration tests will cover user journey acceptance scenarios from spec
- âœ… **PASS**: Unit tests will validate JWT parsing, signature verification, and claim extraction

**VI. API Contract Enforcement**
- âœ… **PASS**: Authentication dependency outputs standardized error responses (FR-012)
- âœ… **PASS**: FastAPI auto-generates OpenAPI documentation for protected endpoints
- âœ… **PASS**: Error responses follow consistent JSON structure

**Technology Standards Compliance**:
- âœ… Python 3.13+
- âœ… FastAPI (latest stable)
- âœ… Better Auth JWT (shared secret verification)
- âœ… pytest for testing
- âœ… ruff for linting/formatting

**Overall Gate Status**: âœ… **PASS** - All principles satisfied. One acceptable exception (no DB persistence) is justified by spec requirement for stateless design.

## Project Structure

### Documentation (this feature)

```text
specs/003-auth-security/
â”œâ”€â”€ spec.md              # Feature requirements (completed)
â”œâ”€â”€ plan.md              # This file (/sp.plan command output)
â”œâ”€â”€ research.md          # Phase 0 output: JWT library comparison, best practices
â”œâ”€â”€ data-model.md        # Phase 1 output: JWT payload structure, error schemas
â”œâ”€â”€ quickstart.md        # Phase 1 output: Developer guide for using auth dependencies
â”œâ”€â”€ contracts/           # Phase 1 output: API error response contracts
â”‚   â””â”€â”€ auth-errors.json # OpenAPI schema for authentication error responses
â””â”€â”€ tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ dependencies.py    # FastAPI authentication/authorization dependencies
â”‚   â”‚   â”œâ”€â”€ jwt_handler.py     # JWT validation, parsing, claim extraction
â”‚   â”‚   â””â”€â”€ exceptions.py      # Custom authentication exception classes
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ auth.py            # Pydantic models for JWT payload, error responses
â”‚   â””â”€â”€ config.py              # Environment variable configuration (BETTER_AUTH_SECRET)
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ contract/
â”‚   â”‚   â””â”€â”€ test_auth_contract.py  # Contract tests for authentication behavior
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â””â”€â”€ test_auth_integration.py  # Integration tests with FastAPI endpoints
â”‚   â””â”€â”€ unit/
â”‚       â”œâ”€â”€ test_jwt_handler.py      # Unit tests for JWT validation logic
â”‚       â””â”€â”€ test_auth_dependencies.py # Unit tests for FastAPI dependencies
â””â”€â”€ .env.example         # Example environment variables (BETTER_AUTH_SECRET template)
```

**Structure Decision**: Web application (Option 2) - Backend-only feature. Code resides exclusively in `/backend/` directory per Multi-Tier Isolation principle. The `auth/` module provides reusable security components that will be imported by other backend features (task management, user management) when protecting their endpoints.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations requiring justification. The one acceptable exception (no database persistence for auth) is explicitly required by the specification's stateless design constraint.

---

# Phase 0: Research

## Research Tasks

### Task 1: Python JWT Library Evaluation

**Objective**: Select the optimal JWT library for HS256 validation in Python 3.13+

**Research Questions**:
- Which Python JWT libraries support HS256 algorithm?
- What are the performance characteristics of each library?
- Which library has the most active maintenance and security track record?
- Which library integrates best with FastAPI and Pydantic?

**Options to Evaluate**:
- `python-jose[cryptography]` - Popular with FastAPI community, cryptography backend
- `PyJWT` - Industry standard, maintained by jpadilla
- `authlib` - Comprehensive auth library by lepture

**Decision Criteria**:
- Security audit history and CVE response time
- Performance (<50ms validation requirement)
- Type hints and Python 3.13 compatibility
- FastAPI integration examples and community support

### Task 2: Better Auth JWT Claim Structure Research

**Objective**: Understand the exact JWT payload structure generated by Better Auth

**Research Questions**:
- What claims does Better Auth include in JWT tokens by default?
- What is the exact key name for user ID (`uid`, `sub`, `user_id`)?
- What additional claims are included (`exp`, `iat`, `iss`, `aud`)?
- What is the JWT header structure (algorithm, token type)?

**Information Sources**:
- Better Auth documentation via MCP search
- Better Auth GitHub repository examples
- Better Auth JWT plugin configuration reference

**Required Output**: Documented JWT payload schema for validation

### Task 3: FastAPI Dependency Best Practices

**Objective**: Design FastAPI dependencies that follow framework conventions

**Research Questions**:
- What is the recommended pattern for authentication dependencies in FastAPI?
- How to handle dependency failures (raise exceptions vs return None)?
- How to extract path parameters within dependencies for authorization?
- How to provide consistent error responses from dependencies?

**Information Sources**:
- FastAPI official documentation (Security section)
- FastAPI dependency injection patterns
- OAuth2PasswordBearer vs custom dependency patterns

**Required Output**: Dependency design pattern with error handling strategy

### Task 4: HS256 Security Best Practices

**Objective**: Ensure secure implementation of HS256 signature verification

**Research Questions**:
- What is the minimum recommended secret length for HS256?
- How to securely load secrets from environment variables?
- What timing attack mitigations are needed for signature comparison?
- What validation steps must occur before trusting JWT claims?

**Information Sources**:
- OWASP JWT security cheatsheet
- RFC 7519 (JSON Web Token) specification
- Python JWT library security documentation

**Required Output**: Security checklist for JWT validation implementation

---

# Phase 1: Design & Contracts

## Data Model

### JWT Token Payload Structure

**Source**: Better Auth JWT plugin output (to be verified via research)

```python
# Expected JWT payload structure from Better Auth
{
    "uid": "string",           # User unique identifier (primary claim for authorization)
    "exp": int,                # Expiration timestamp (Unix epoch seconds)
    "iat": int,                # Issued at timestamp (Unix epoch seconds)
    # Additional claims TBD based on Better Auth configuration
}
```

**Validation Requirements**:
- `uid` must be present and non-empty string
- `exp` must be present and greater than current timestamp
- `iat` must be present and less than or equal to current timestamp
- Signature must verify using BETTER_AUTH_SECRET with HS256 algorithm

### Authentication Error Response Schema

```json
{
  "detail": "string",          // Human-readable error message
  "error_code": "string",      // Machine-readable error identifier
  "status_code": int           // HTTP status code (401 or 403)
}
```

**Error Codes**:
- `MISSING_TOKEN`: Authorization header not provided
- `INVALID_HEADER_FORMAT`: Authorization header not in "Bearer <token>" format
- `INVALID_TOKEN_SIGNATURE`: JWT signature verification failed
- `TOKEN_EXPIRED`: JWT exp claim is in the past
- `MALFORMED_TOKEN`: JWT parsing failed (invalid structure)
- `MISSING_UID_CLAIM`: JWT payload missing required uid claim
- `FORBIDDEN_USER_ACCESS`: Authenticated user attempting to access different user's resources

### Configuration Schema

```python
# Environment variables required for authentication
BETTER_AUTH_SECRET: str      # Shared secret for HS256 verification (REQUIRED)
```

**Startup Validation**:
- Application must fail to start if BETTER_AUTH_SECRET is missing or empty
- Secret must be at least 32 characters (256 bits) for HS256 security

## API Contracts

### Authentication Dependency Contract

**Dependency**: `get_current_user`

**Input**:
- HTTP Header: `Authorization: Bearer <jwt_token>`

**Output**:
- **Success**: Returns authenticated user ID (string) extracted from JWT `uid` claim
- **Failure**: Raises HTTPException with appropriate 401 status code and error detail

**Error Scenarios**:
| Scenario | Status Code | Error Code | Error Message |
|----------|-------------|------------|---------------|
| Missing Authorization header | 401 | MISSING_TOKEN | "Missing authentication token" |
| Invalid header format (not "Bearer <token>") | 401 | INVALID_HEADER_FORMAT | "Invalid authorization header format" |
| Invalid signature | 401 | INVALID_TOKEN_SIGNATURE | "Invalid token signature" |
| Expired token | 401 | TOKEN_EXPIRED | "Token expired" |
| Malformed token | 401 | MALFORMED_TOKEN | "Malformed token" |
| Missing uid claim | 401 | MISSING_UID_CLAIM | "Invalid token: missing or malformed user ID claim" |

### Authorization Dependency Contract

**Dependency**: `verify_user_access`

**Input**:
- HTTP Header: `Authorization: Bearer <jwt_token>`
- Path Parameter: `{user_id}` (string)

**Output**:
- **Success**: Returns authenticated user ID (string) if it matches `{user_id}` path parameter
- **Authentication Failure**: Raises HTTPException with 401 status (same as `get_current_user`)
- **Authorization Failure**: Raises HTTPException with 403 status if user ID mismatch

**Error Scenarios**:
| Scenario | Status Code | Error Code | Error Message |
|----------|-------------|------------|---------------|
| All authentication errors | 401 | (see above) | (see above) |
| User ID mismatch | 403 | FORBIDDEN_USER_ACCESS | "Access denied: cannot access another user's resources" |

**Usage Pattern**:
```python
# Example protected endpoint
@router.get("/users/{user_id}/tasks")
async def get_user_tasks(
    user_id: str,
    current_user_id: str = Depends(verify_user_access)
):
    # current_user_id is guaranteed to equal user_id
    # Safe to proceed with business logic
    pass
```

## Key Architectural Decisions

### Decision 1: JWT Library Selection

**Decision**: Use `python-jose[cryptography]`

**Rationale**:
- Officially recommended by FastAPI documentation
- Comprehensive JWT support with cryptography backend
- Active maintenance and security updates
- Excellent FastAPI integration examples
- Type hint support for Python 3.13+

**Alternatives Considered**:
- `PyJWT`: Industry standard but less FastAPI-specific examples
- `authlib`: More comprehensive but heavier dependency (includes OAuth, OpenID)

**Implementation Impact**:
- Dependency: `python-jose[cryptography]>=3.3.0`
- Import path: `from jose import jwt, JWTError`

### Decision 2: Dependency Error Handling Pattern

**Decision**: Raise `HTTPException` from dependencies (not `return None`)

**Rationale**:
- FastAPI convention for authentication dependencies
- Prevents endpoint handlers from having to check `if user is None`
- Consistent error responses across all protected endpoints
- Automatic OpenAPI documentation of authentication requirements

**Alternatives Considered**:
- Return `Optional[str]`: Requires every endpoint to handle None case (error-prone)
- Custom exception types: Adds complexity without benefit (HTTPException sufficient)

**Implementation Impact**:
```python
from fastapi import HTTPException, status

def verify_token(token: str) -> str:
    if not valid:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token expired",
            headers={"WWW-Authenticate": "Bearer"}
        )
    return user_id
```

### Decision 3: User ID Path Parameter Extraction

**Decision**: Accept `user_id: str` as explicit parameter to `verify_user_access` dependency

**Rationale**:
- Explicit is better than implicit (Zen of Python)
- FastAPI automatically injects path parameters into dependencies
- Clear contract: dependency requires user_id to perform authorization
- Type-safe: user_id parameter validated by Pydantic

**Alternatives Considered**:
- Parse path from Request object: Fragile (assumes URL structure)
- Use starlette.requests.Request.path_params: Less explicit, harder to test

**Implementation Impact**:
```python
async def verify_user_access(
    user_id: str,  # Automatically injected from path parameter {user_id}
    current_user_id: str = Depends(get_current_user)
) -> str:
    if current_user_id != user_id:
        raise HTTPException(status_code=403, ...)
    return current_user_id
```

### Decision 4: Environment Variable Loading

**Decision**: Use `pydantic-settings` for environment variable validation

**Rationale**:
- Type-safe configuration with validation
- Automatic parsing of environment variables
- Fail-fast on missing required secrets (SC-007 requirement)
- Integrates with FastAPI/Pydantic ecosystem

**Alternatives Considered**:
- `python-dotenv` + manual validation: More boilerplate, less type-safe
- `os.getenv()`: No validation, runtime errors instead of startup errors

**Implementation Impact**:
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    BETTER_AUTH_SECRET: str  # Required field - raises error if missing

    class Config:
        env_file = ".env"
        min_anystr_length = 32  # Enforce minimum secret length

settings = Settings()  # Fails on import if BETTER_AUTH_SECRET invalid
```

## Testing Strategy

### Contract Tests

**File**: `tests/contract/test_auth_contract.py`

**Scenarios**:
1. Valid token with correct user ID â†’ 200 OK
2. Valid token with mismatched user ID â†’ 403 Forbidden
3. Expired token â†’ 401 Unauthorized
4. Invalid signature â†’ 401 Unauthorized
5. Missing Authorization header â†’ 401 Unauthorized
6. Malformed Authorization header â†’ 401 Unauthorized

**Test Data**:
- Generate valid JWT tokens using test secret
- Generate expired tokens (exp in past)
- Generate invalid signatures (wrong secret)
- Generate malformed tokens (invalid JSON, missing claims)

### Integration Tests

**File**: `tests/integration/test_auth_integration.py`

**Scenarios**:
1. Protected endpoint rejects unauthenticated requests
2. Protected endpoint accepts valid token with correct user ID
3. User-scoped endpoint rejects valid token with different user ID
4. Multiple concurrent requests with same token (stateless validation)
5. Error response format matches contract specification

**Setup**:
- Create test FastAPI app with protected endpoints
- Use `TestClient` from `fastapi.testclient`
- Mock BETTER_AUTH_SECRET with test value

### Unit Tests

**File**: `tests/unit/test_jwt_handler.py`

**Scenarios**:
1. `decode_jwt()` validates signature correctly
2. `decode_jwt()` rejects expired tokens
3. `decode_jwt()` extracts uid claim correctly
4. `decode_jwt()` raises appropriate exceptions for invalid tokens
5. `extract_bearer_token()` parses Authorization header correctly
6. `extract_bearer_token()` rejects malformed headers

**File**: `tests/unit/test_auth_dependencies.py`

**Scenarios**:
1. `get_current_user()` dependency calls jwt_handler correctly
2. `get_current_user()` raises HTTPException for invalid tokens
3. `verify_user_access()` compares user IDs correctly
4. `verify_user_access()` raises 403 for mismatched user IDs

## Implementation Phases

### Phase 0 Deliverables âœ…

- [x] `research.md` - JWT library evaluation, Better Auth claim structure, best practices
- [x] Architecture decisions documented above

### Phase 1 Deliverables âœ…

- [x] `data-model.md` - JWT payload schema, error response schema, configuration schema
- [x] `contracts/auth-errors.json` - OpenAPI error response contracts
- [x] `quickstart.md` - Developer guide for using authentication dependencies
- [x] Agent context updated (technology stack additions)

### Phase 2 Deliverables (via `/sp.tasks`)

- [ ] `tasks.md` - Actionable, dependency-ordered implementation tasks
- [ ] Task execution via `/sp.implement`

## Security Considerations

1. **Secret Management**:
   - BETTER_AUTH_SECRET must never be committed to version control
   - Use `.env` file for local development (add to `.gitignore`)
   - Use environment variable injection for production deployment

2. **Timing Attack Mitigation**:
   - JWT libraries use constant-time comparison for signatures (handled by python-jose)
   - No custom string comparison needed

3. **Token Expiration**:
   - Rely on Better Auth to set appropriate expiration times (15-30 minutes recommended)
   - Backend enforces expiration via `exp` claim validation
   - No grace period for expired tokens (strict validation)

4. **Error Information Disclosure**:
   - Return generic error messages to clients ("Invalid token signature")
   - Log detailed error information server-side for debugging
   - Never expose secret material or internal state in error responses

## Next Steps

1. âœ… Phase 1 complete - Architecture designed, contracts defined
2. ðŸ”„ Run `/sp.tasks` to generate actionable implementation tasks
3. ðŸ”„ Run `/sp.implement` to execute tasks with TDD workflow
4. ðŸ”„ Validate against acceptance criteria from spec.md
