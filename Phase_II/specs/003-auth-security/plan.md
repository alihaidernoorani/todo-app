# Implementation Plan: Stateless JWT Authentication

**Branch**: `003-auth-security` | **Date**: 2026-02-07 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-auth-security/spec.md`

**Note**: This plan migrates from session-cookie based authentication to stateless JWT authentication using RS256 and JWKS for cross-domain deployment.

## Summary

Migrate the authentication architecture from session-cookie based (Better Auth sessions with `/api/auth/session` endpoint dependency) to stateless JWT authentication using RS256 signature verification with JWKS public keys. The backend will perform local JWT verification without external API calls, enabling true stateless operation across different domains (Next.js on Vercel, FastAPI on HuggingFace). Frontend will store JWT tokens in localStorage and send them via `Authorization: Bearer <token>` header. Backend will verify tokens using public keys fetched from Better Auth's JWKS endpoint and extract user identity from the `sub` claim.

**Architectural principle**: Stateless local JWT verification - no session endpoint dependencies.

## Technical Context

**Language/Version**: Python 3.13+ (backend), TypeScript 5.x (frontend)
**Primary Dependencies**:
- Backend: FastAPI, PyJWT>=2.8.0, cryptography>=41.0.0, httpx>=0.24.0, pydantic>=2.0.0
- Frontend: Next.js 16+, Better Auth with JWT plugin, TypeScript

**Storage**: Neon PostgreSQL (user data only, no session storage)
**Testing**: pytest (backend), Jest/Vitest (frontend)
**Target Platform**:
- Backend: HuggingFace Spaces (Linux server)
- Frontend: Vercel (Edge + Node.js runtime)

**Project Type**: Web (frontend + backend)
**Performance Goals**:
- JWT verification <10ms using cached JWKS keys
- JWKS cache refresh every 1 hour
- Zero latency for session state (fully stateless)

**Constraints**:
- No session storage or cookies allowed (cross-domain requirement)
- Must operate statelessly (no backend state, no session endpoint calls)
- JWKS endpoint must be publicly accessible
- Tokens must be short-lived (15-60 minutes) to limit exposure

**Scale/Scope**:
- Affects all protected API endpoints (~10 routes)
- 2 FastAPI dependencies to refactor
- 4 frontend authentication flows to update
- End-to-end authentication test coverage

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Multi-Tier Isolation ✅
- **Status**: PASS
- **Rationale**: All changes stay within `/frontend/` and `/backend/` boundaries. No Phase 1 code affected.

### Persistence First ✅
- **Status**: PASS (Not Applicable)
- **Rationale**: JWT authentication is stateless by design. User data remains in Neon PostgreSQL via SQLModel. Session state is eliminated entirely.

### Secure by Design ✅
- **Status**: PASS
- **Rationale**: RS256 cryptographic signature verification with JWKS public keys is more secure than session cookies. Eliminates session hijacking and CSRF attacks. Enforces token expiration and issuer validation.

### Zero Manual Coding ✅
- **Status**: PASS
- **Rationale**: All implementation generated by Claude Code. Traceable via PHR in `history/prompts/003-auth-security/`.

### Test-First Discipline ⚠️
- **Status**: CONDITIONAL PASS
- **Rationale**: Tests will be written during implementation phase (`/sp.implement`). Contract tests defined in Phase 1 (contracts/). Integration tests for JWT verification flow will be added.

### API Contract Enforcement ✅
- **Status**: PASS
- **Rationale**: JWT tokens transport authentication via standard `Authorization: Bearer <token>` header. Error responses remain consistent (401/403 with JSON structure). No breaking API changes.

**Overall Gate Status**: ✅ PASS - Proceed to Phase 0

## Project Structure

### Documentation (this feature)

```text
specs/003-auth-security/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command)
├── data-model.md        # Phase 1 output (/sp.plan command)
├── quickstart.md        # Phase 1 output (/sp.plan command)
├── contracts/           # Phase 1 output (/sp.plan command)
│   ├── jwt-verification.yaml  # JWT verification contract
│   └── error-responses.yaml   # Error response schemas
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
backend/
├── src/
│   ├── auth/
│   │   ├── __init__.py
│   │   ├── dependencies.py          # MODIFY: Replace session validation with JWT verification
│   │   ├── jwt_verifier.py          # CREATE: JWT verification logic with JWKS
│   │   ├── models.py                # MODIFY: Update AuthenticatedUser model
│   │   └── session_validator.py    # DELETE: Remove session endpoint dependency
│   ├── api/v1/
│   │   └── auth.py                  # MODIFY: Update /me endpoint
│   ├── config.py                    # MODIFY: Replace BETTER_AUTH_URL with JWKS_URL
│   └── main.py                      # VERIFY: CORS already supports Authorization header
└── tests/
    ├── test_jwt_verifier.py         # CREATE: Unit tests for JWT verification
    └── test_auth_dependencies.py    # MODIFY: Update dependency tests

frontend/
├── lib/
│   ├── auth/
│   │   ├── better-auth.ts           # MODIFY: Enable JWT plugin with RS256
│   │   ├── better-auth-client.ts    # VERIFY: Client already configured
│   │   └── useSession.ts            # MODIFY: Remove session endpoint dependency
│   ├── api/
│   │   └── client.ts                # MODIFY: Add Authorization header, remove cookies
│   └── hooks/
│       └── use-auth-redirect.ts     # MODIFY: Use token presence instead of session
├── app/api/auth/
│   ├── [...all]/route.ts            # VERIFY: Better Auth routes (no changes)
│   └── session/route.ts             # DELETE: Remove custom session endpoint
└── tests/
    └── auth-flow.test.ts            # CREATE: E2E JWT authentication flow test
```

**Structure Decision**: Web application structure. Changes affect both frontend and backend tiers. All modifications stay within established boundaries. No shared code between tiers (JWT tokens are self-contained).

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations detected. All constitution principles satisfied.

---

## Phase 0: Research & Unknowns Resolution

### Research Tasks

**RT-001: Better Auth JWT Plugin Configuration**
- **Question**: How to enable Better Auth JWT plugin with RS256 signing?
- **Research Target**: Better Auth documentation for JWT plugin setup
- **Deliverable**: Configuration snippet for `better-auth.ts` with JWT plugin enabled
- **Critical Path**: Blocks frontend implementation

**RT-002: JWKS Endpoint Discovery**
- **Question**: What is the JWKS endpoint URL format for Better Auth?
- **Research Target**: Better Auth JWKS endpoint location (standard: `/.well-known/jwks.json`)
- **Deliverable**: Confirmed JWKS URL pattern and response format
- **Critical Path**: Blocks backend JWT verification implementation

**RT-003: PyJWT RS256 Verification**
- **Question**: How to verify RS256 JWT signatures using PyJWT with JWKS public keys?
- **Research Target**: PyJWT library documentation for RS256 verification with JWK
- **Deliverable**: Code pattern for fetching JWKS, caching keys, and verifying tokens
- **Critical Path**: Blocks backend JWT verifier module

**RT-004: JWKS Caching Strategy**
- **Question**: What caching strategy prevents JWKS endpoint overload while ensuring key rotation?
- **Research Target**: Industry best practices for JWKS caching (TTL, cache invalidation)
- **Deliverable**: Caching policy with TTL recommendation (typical: 1 hour)
- **Critical Path**: Blocks backend performance optimization

**RT-005: Frontend JWT Storage Security**
- **Question**: Is localStorage secure for JWT tokens? What are XSS mitigation strategies?
- **Research Target**: OWASP recommendations for token storage in SPAs
- **Deliverable**: Security guidelines and CSP header recommendations
- **Critical Path**: Blocks frontend security implementation

**RT-006: Token Lifecycle Management**
- **Question**: How does Better Auth handle token refresh with JWT plugin?
- **Research Target**: Better Auth JWT plugin refresh token flow
- **Deliverable**: Token refresh implementation pattern for frontend
- **Critical Path**: Blocks frontend token expiry handling

**RT-007: FastAPI Dependency Pattern for JWT**
- **Question**: What is the idiomatic FastAPI pattern for JWT extraction and verification?
- **Research Target**: FastAPI security patterns for JWT authentication
- **Deliverable**: FastAPI dependency decorator pattern with error handling
- **Critical Path**: Blocks backend dependency refactoring

**RT-008: JWKS Startup Validation**
- **Question**: How to fail application startup if JWKS endpoint is unreachable?
- **Research Target**: FastAPI lifespan events for startup validation
- **Deliverable**: Startup validation code with error handling
- **Critical Path**: Blocks backend deployment safety

### Output: `research.md`

Document will include:
- Decision matrix for each research task
- Rationale for chosen approaches
- Alternative approaches considered and rejected
- Code snippets and configuration examples
- Security considerations and best practices

## Phase 1: Design & Contracts

### Phase 1A: Data Model

**Output**: `data-model.md`

**Entities to Define**:

1. **JWT Token Structure**
   - Standard claims: `sub` (user ID), `iss` (issuer), `exp` (expiration), `iat` (issued at)
   - Optional claims: `email`, `name`, `aud` (audience)
   - Signature algorithm: RS256
   - Token format: `header.payload.signature` (Base64url encoded)

2. **JWKS Key Format**
   - Key fields: `kid` (key ID), `kty` (key type), `alg` (algorithm), `n` (modulus), `e` (exponent)
   - Response format: `{ "keys": [{ "kid": "...", ... }] }`

3. **AuthenticatedUser Model** (Backend)
   - `user_id: str` - Extracted from JWT `sub` claim
   - `email: str` - Extracted from JWT `email` claim
   - `name: Optional[str]` - Extracted from JWT `name` claim
   - `exp: datetime` - Token expiration timestamp
   - `iss: str` - Token issuer for validation

4. **JWKS Cache Entry**
   - `kid: str` - Key identifier
   - `public_key: RSAPublicKey` - Parsed RSA public key object
   - `cached_at: datetime` - Cache timestamp
   - `ttl: int` - Time-to-live in seconds (default: 3600)

5. **JWT Verification Result**
   - `valid: bool` - Signature verification result
   - `user: Optional[AuthenticatedUser]` - Extracted user data if valid
   - `error: Optional[str]` - Error message if invalid
   - `error_code: Optional[str]` - Error code (expired, invalid_signature, missing_claim, etc.)

**Validation Rules**:
- Token expiration (`exp` claim) must be in the future
- Token issuer (`iss` claim) must match expected Better Auth URL
- Required claims (`sub`, `exp`, `iss`) must be present
- Signature verification must pass with JWKS public key matching `kid`

### Phase 1B: API Contracts

**Output**: `contracts/jwt-verification.yaml` (OpenAPI format)

### Phase 1C: Quickstart Guide

**Output**: `quickstart.md`

Structure:
1. **Environment Setup** - Frontend/backend configuration
2. **Frontend Flow** - Sign in, extract token, send in Authorization header
3. **Backend Flow** - Extract header, verify signature, extract user identity
4. **Testing** - Validation steps for JWT authentication
5. **Deployment Checklist** - Production readiness

---

## Phase 2: Task Generation

**Blocked until Phase 1 complete.**

Output: `tasks.md` (created by `/sp.tasks` command, not by this plan command)

Expected task categories:
1. **Backend JWT Verification** (5-7 tasks)
2. **Frontend JWT Integration** (4-6 tasks)
3. **Cleanup & Migration** (2-3 tasks)
4. **Security & Testing** (2-3 tasks)

**Total Estimated Tasks**: 13-19 tasks (dependency-ordered)

---

## Migration Strategy

### Phased Rollout (Recommended)

**Phase A: Backend Preparation** (Zero Downtime)
1. Add JWT verification dependencies alongside existing session validator
2. Implement new JWT-based authentication dependency (`get_current_user_jwt`)
3. Deploy backend with both authentication methods supported
4. Verify JWT verification works with test tokens

**Phase B: Frontend Migration** (Low Risk)
1. Enable Better Auth JWT plugin
2. Update sign-in flow to capture JWT tokens
3. Store tokens in localStorage
4. Update API client to send both cookies and Authorization header
5. Deploy frontend with dual authentication support
6. Monitor for errors

**Phase C: Backend Cutover** (Controlled)
1. Switch endpoints to use JWT-only authentication dependency
2. Remove session endpoint calls from backend
3. Deploy backend with JWT-only validation
4. Monitor authentication success rate

**Phase D: Cleanup** (Safe)
1. Remove session validator module from backend
2. Remove custom session endpoint from frontend
3. Remove cookie handling from API client
4. Update documentation

### Rollback Plan

If JWT authentication fails:
1. Revert backend to session-based dependencies (git revert)
2. Revert frontend API client to cookie-based requests
3. Disable JWT plugin in Better Auth configuration
4. Investigate failure root cause
5. Fix and retry migration

---

## Risk Analysis

### Risk 1: JWKS Endpoint Unavailable at Startup
- **Impact**: High (application won't start)
- **Mitigation**: Implement startup validation with clear error messages
- **Fallback**: Cached JWKS keys from previous run (with expiration check)

### Risk 2: Better Auth JWT Plugin Misconfiguration
- **Impact**: High (authentication fails entirely)
- **Mitigation**: Test JWT generation in development environment first
- **Detection**: Verify JWKS endpoint returns valid RS256 keys

### Risk 3: Token Storage XSS Vulnerability
- **Impact**: Medium (tokens could be stolen via XSS)
- **Mitigation**: Implement Content Security Policy (CSP) headers
- **Best Practice**: Use short-lived tokens (15-60 minutes)

### Risk 4: JWKS Cache Poisoning
- **Impact**: Low (attacker needs to compromise JWKS endpoint)
- **Mitigation**: Validate JWKS response structure before caching
- **Best Practice**: Use HTTPS for JWKS endpoint in production

### Risk 5: Cross-User Access During Migration
- **Impact**: High (privilege escalation)
- **Mitigation**: Maintain user ID scoping validation throughout migration
- **Testing**: Add specific tests for user ID mismatch scenarios

---

## Success Metrics

### Technical Metrics
- ✅ JWT verification completes in <10ms (cached JWKS)
- ✅ Zero session endpoint calls from backend
- ✅ Zero cookies sent/received for authentication
- ✅ 100% of protected endpoints use JWT verification
- ✅ JWKS cache hit rate >99% (1-hour TTL)

### Security Metrics
- ✅ 100% of invalid tokens rejected with 401
- ✅ 100% of expired tokens rejected with 401
- ✅ 100% of cross-user access attempts blocked with 403
- ✅ Zero session state stored on backend

### Reliability Metrics
- ✅ Application fails to start if JWKS unreachable (fail-safe)
- ✅ Cached JWKS keys allow operation during temporary outages
- ✅ All authentication errors return consistent JSON format

---

## Dependencies

### External Services
- Better Auth JWKS endpoint must be publicly accessible
- Better Auth JWT plugin must support RS256 signing
- HTTPS required in production for token security

### Python Libraries (Backend)
- `PyJWT>=2.8.0` - JWT parsing and RS256 verification
- `cryptography>=41.0.0` - RSA cryptographic operations
- `httpx>=0.24.0` - Async HTTP client for JWKS fetching
- `pydantic>=2.0.0` - Data validation for JWT claims

### TypeScript Libraries (Frontend)
- Better Auth JWT plugin (included in Better Auth)
- No additional dependencies required

### Infrastructure
- Environment variables: `BETTER_AUTH_URL`, `BETTER_AUTH_JWKS_URL` (backend)
- Environment variables: `BETTER_AUTH_URL`, `BETTER_AUTH_SECRET` (frontend)
- CORS configuration: Allow `Authorization` header

---

## Next Steps

1. ✅ **Phase 0**: Plan complete (this file)
2. ⏳ **Phase 1**: Generate data models, API contracts, and quickstart guide → `data-model.md`, `contracts/`, `quickstart.md`
3. ⏳ **Phase 2**: Run `/sp.tasks` to generate dependency-ordered task list → `tasks.md`
4. ⏳ **Phase 3**: Run `/sp.implement` to execute tasks with AI assistance
5. ⏳ **Phase 4**: Validate against spec acceptance criteria and iterate

**Current Status**: Plan complete. Ready for Phase 1 design.

**Command to continue**: `/sp.plan` will continue with Phase 1, or manually proceed with data modeling.

---

**Plan Version**: 1.0.0
**Created**: 2026-02-07
**Status**: Complete - Ready for Phase 1
